"""Business logic for ICS-214 module."""
from __future__ import annotations

import hashlib
import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any

from sqlalchemy import select

from .models import (
    ICS214Stream,
    ICS214Entry,
    ICS214IngestRule,
    ICS214Export,
)
from .schemas import EntryCreate, StreamCreate, StreamUpdate, ExportRequest
from modules._infra.repository import with_incident_session
from .ws import manager as ws_manager

# Permission stubs ------------------------------------------------------------

def can_read(user_id: str, stream: ICS214Stream) -> bool:
    return True

def can_write(user_id: str, stream: ICS214Stream) -> bool:
    return True

# Stream CRUD ----------------------------------------------------------------

def create_stream(data: StreamCreate) -> ICS214Stream:
    with with_incident_session(data.incident_id) as session:
        stream = ICS214Stream(id=str(uuid.uuid4()), **data.model_dump())
        session.add(stream)
        session.flush()
        return stream


def list_streams(incident_id: str) -> List[ICS214Stream]:
    with with_incident_session(incident_id) as session:
        result = session.execute(select(ICS214Stream)).scalars().all()
        return result


def update_stream(incident_id: str, stream_id: str, data: StreamUpdate) -> ICS214Stream | None:
    with with_incident_session(incident_id) as session:
        stream = session.get(ICS214Stream, stream_id)
        if not stream:
            return None
        for field, value in data.model_dump(exclude_unset=True).items():
            setattr(stream, field, value)
        session.add(stream)
        session.flush()
        return stream

# Entries ---------------------------------------------------------------------

def _entry_to_dict(entry: ICS214Entry) -> Dict[str, Any]:
    return {
        "id": entry.id,
        "stream_id": entry.stream_id,
        "timestamp_utc": entry.timestamp_utc.isoformat(),
        "text": entry.text,
        "source": entry.source,
        "actor_user_id": entry.actor_user_id,
        "autogenerated": entry.autogenerated,
        "critical_flag": entry.critical_flag,
        "idempotency_hash": entry.idempotency_hash,
        "tags": entry.tags or [],
    }


def add_entry(incident_id: str, stream_id: str, data: EntryCreate, autogenerated: bool = False, id_hash: str | None = None) -> Dict[str, Any]:
    with with_incident_session(incident_id) as session:
        stream = session.get(ICS214Stream, stream_id)
        if not stream:
            raise ValueError("Stream not found")
        timestamp = data.timestamp_utc or datetime.utcnow()
        if not id_hash:
            hash_input = f"manual:{uuid.uuid4()}".encode()
            id_hash = hashlib.sha256(hash_input).hexdigest()
        entry = ICS214Entry(
            id=str(uuid.uuid4()),
            stream_id=stream_id,
            timestamp_utc=timestamp,
            text=data.text,
            source=data.source,
            actor_user_id=data.actor_user_id,
            critical_flag=data.critical_flag,
            tags=data.tags,
            autogenerated=autogenerated,
            idempotency_hash=id_hash,
        )
        session.add(entry)
        session.flush()
        payload = _entry_to_dict(entry)
    ws_manager.broadcast(stream_id, payload)
    return payload


def list_entries(incident_id: str, stream_id: str) -> List[Dict[str, Any]]:
    with with_incident_session(incident_id) as session:
        result = session.execute(
            select(ICS214Entry).where(ICS214Entry.stream_id == stream_id).order_by(ICS214Entry.timestamp_utc)
        ).scalars().all()
        return [_entry_to_dict(e) for e in result]


def update_entry(incident_id: str, entry_id: str, data: "EntryUpdate") -> Dict[str, Any] | None:
    from .schemas import EntryUpdate
    if not isinstance(data, EntryUpdate):
        data = EntryUpdate(**(data or {}))
    with with_incident_session(incident_id) as session:
        entry = session.get(ICS214Entry, entry_id)
        if not entry:
            return None
        payload = data.model_dump(exclude_unset=True)
        for k, v in payload.items():
            if hasattr(entry, k):
                setattr(entry, k, v)
        session.add(entry)
        session.flush()
        return _entry_to_dict(entry)


def delete_entry(incident_id: str, entry_id: str) -> bool:
    with with_incident_session(incident_id) as session:
        entry = session.get(ICS214Entry, entry_id)
        if not entry:
            return False
        session.delete(entry)
        session.flush()
        return True

# Event ingestion -------------------------------------------------------------

def ingest_event_to_entries(event: Dict[str, Any]) -> List[Dict[str, Any]]:
    incident_id = event["incident_id"]
    topic = event["topic"]
    created: List[Dict[str, Any]] = []
    with with_incident_session(incident_id) as session:
        rules = session.execute(
            select(ICS214IngestRule).where(ICS214IngestRule.topic == topic, ICS214IngestRule.enabled == True)
        ).scalars().all()
    for rule in rules:
        text = rule.template.format(**event.get("payload", {}))
        hash_input = (event["event_id"] + rule.stream_id).encode()
        id_hash = hashlib.sha256(hash_input).hexdigest()
        try:
            created.append(
                add_entry(
                    incident_id,
                    rule.stream_id,
                    EntryCreate(text=text, source="auto"),
                    autogenerated=True,
                    id_hash=id_hash,
                )
            )
        except Exception:
            # Duplicate entry hash -> ignore
            continue
    return created

# Export ---------------------------------------------------------------------

def export_stream(incident_id: str, stream_id: str, options: ExportRequest) -> ICS214Export:
    entries = list_entries(incident_id, stream_id)
    if not options.include_auto:
        entries = [e for e in entries if not e["autogenerated"]]
    base_dir = Path("data") / "uploads" / "ics214" / incident_id
    base_dir.mkdir(parents=True, exist_ok=True)
    filename = f"{stream_id}_{int(datetime.utcnow().timestamp())}.pdf"
    file_path = base_dir / filename
    from .export_pdf import render_pdf

    render_pdf(entries, str(file_path))

    with with_incident_session(incident_id) as session:
        exp = ICS214Export(id=str(uuid.uuid4()), stream_id=stream_id, file_path=str(file_path))
        session.add(exp)
        session.flush()
        return exp
