"""QtWidgets implementation for the redesigned ICS-214 Activity Log module."""
from __future__ import annotations

from dataclasses import dataclass, field, replace
from datetime import datetime, timezone
import logging
from pathlib import Path
import sqlite3
from typing import Any, Sequence
from uuid import uuid4

from PySide6.QtCore import QDate, QDateTime, QTime, QPoint, Qt, Signal
from PySide6.QtGui import QColor
from PySide6.QtWidgets import (
    QAbstractItemView,
    QCheckBox,
    QComboBox,
    QDateTimeEdit,
    QDialog,
    QDialogButtonBox,
    QFormLayout,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMenu,
    QMessageBox,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from models.incidentlist import load_incidents_from_master

from .. import services as ics214_services
from ..schemas import (
    EntryCreate,
    EntryUpdate,
    StreamCreate,
    StreamUpdate,
    ExportRequest,
)
from utils import incident_context

logger = logging.getLogger(__name__)


def _now_local() -> QDateTime:
    dt = QDateTime.currentDateTime()
    dt.setTimeSpec(Qt.LocalTime)
    return dt


@dataclass
class EntryData:
    """Container for editable ICS-214 entry attributes."""

    timestamp: QDateTime = field(default_factory=_now_local)
    author: str = ""
    source: str = "manual"
    activity: str = ""
    location: str = ""
    links: list[str] = field(default_factory=list)
    attachments: list[str] = field(default_factory=list)
    autogenerated: bool = False
    critical: bool = False

    def clone(self) -> "EntryData":
        return replace(
            self,
            timestamp=QDateTime(self.timestamp),
            links=list(self.links),
            attachments=list(self.attachments),
        )


@dataclass
class LogEntry:
    """Saved entry rendered in the main log table."""

    entry_id: str
    data: EntryData


@dataclass
class DraftEntry:
    """Auto-generated draft awaiting review."""

    draft_id: int
    data: EntryData
    selected: bool = True


@dataclass
class LogHeader:
    """Metadata describing the active ICS-214 log."""

    log_for_type: str = ""
    log_for_label: str = ""
    unit_or_resource: str = ""
    operational_period: str = ""
    status: str | None = None
    version: int = 1
    prepared_by_name: str | None = None
    prepared_by_position: str | None = None
    start: QDateTime = field(default_factory=_now_local)
    end: QDateTime | None = None
    notes: str = ""
    identifier: str = field(default_factory=lambda: uuid4().hex)
    incident_id: str | None = None
    stream_id: str | None = None
    op_number: int | None = None
    section: str | None = None
    kind: str | None = None
    updated_at: QDateTime | None = None

    def clone(self) -> "LogHeader":
        cp = replace(self)
        if self.start.isValid():
            cp.start = QDateTime(self.start)
        if self.end is not None and self.end.isValid():
            cp.end = QDateTime(self.end)
        if self.updated_at is not None and self.updated_at.isValid():
            cp.updated_at = QDateTime(self.updated_at)
        return cp

    def is_prepared(self) -> bool:
        return bool(self.prepared_by_name and self.prepared_by_position)


def format_local_time(dt: QDateTime) -> str:
    if not dt.isValid():
        return "—"
    return dt.toLocalTime().toString("HH:mm MM/dd")


def format_header_time(dt: QDateTime | None) -> str:
    if dt is None or not dt.isValid():
        return "—"
    return dt.toLocalTime().toString("yyyy-MM-dd HH:mm")


def _to_qdatetime(value: datetime | str | None) -> QDateTime:
    if value is None:
        return QDateTime()
    if isinstance(value, str):
        try:
            value = datetime.fromisoformat(value)
        except ValueError:
            return QDateTime()
    if not isinstance(value, datetime):
        return QDateTime()
    if value.tzinfo is None:
        value = value.replace(tzinfo=timezone.utc)
    else:
        value = value.astimezone(timezone.utc)
    qdate = QDate(value.year, value.month, value.day)
    qtime = QTime(value.hour, value.minute, value.second, int(value.microsecond / 1000))
    return QDateTime(qdate, qtime, Qt.UTC)


def _qdatetime_to_utc(dt: QDateTime) -> datetime:
    if not dt.isValid():
        return datetime.utcnow()
    as_utc = dt.toUTC()
    qdate = as_utc.date()
    qtime = as_utc.time()
    return datetime(
        qdate.year(),
        qdate.month(),
        qdate.day(),
        qtime.hour(),
        qtime.minute(),
        qtime.second(),
        qtime.msec() * 1000,
    )


def _split_tags(tags: Sequence[Any] | None) -> tuple[list[str], str]:
    clean: list[str] = []
    location = ""
    for raw in tags or []:
        tag = str(raw)
        if tag.startswith("loc:"):
            if not location:
                location = tag[4:].strip()
        elif tag:
            clean.append(tag)
    return clean, location


def _encode_tags(location: str, tags: Sequence[str]) -> list[str]:
    encoded = [tag for tag in tags if tag]
    if location:
        encoded.append(f"loc:{location}")
    return encoded


def _parse_op_number(value: str | int | None) -> int:
    if value is None:
        return 0
    if isinstance(value, int):
        return value
    digits = "".join(ch for ch in str(value) if ch.isdigit())
    return int(digits) if digits else 0


def _format_timestamp_label(value: str | None) -> str:
    if not value:
        return ""
    try:
        dt = datetime.fromisoformat(value)
    except ValueError:
        return value
    return dt.strftime("%Y-%m-%d %H:%M")


def _format_operational_period_label(code: str | None, start: str | None, end: str | None) -> str:
    label = code or "OP"
    start_txt = _format_timestamp_label(start)
    end_txt = _format_timestamp_label(end)
    if start_txt and end_txt:
        return f"{label} ({start_txt} – {end_txt})"
    if start_txt:
        return f"{label} ({start_txt})"
    return label


class EntryEditorDialog(QDialog):
    """Rich editor dialog for ICS-214 entries."""

    def __init__(
        self,
        entry: EntryData | None = None,
        parent: QWidget | None = None,
        *,
        title: str | None = None,
        read_only: bool = False,
    ) -> None:
        super().__init__(parent)
        self._original = entry.clone() if entry else EntryData()
        self._result = self._original.clone()
        self._read_only = read_only
        self.save_and_new_requested = False
        self.setWindowTitle(title or "Edit Entry")
        self._build_ui()
        self._apply_entry(self._original)

    @property
    def result(self) -> EntryData:
        return self._result

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.time_edit = QDateTimeEdit(self)
        self.time_edit.setDisplayFormat("yyyy-MM-dd HH:mm")
        self.time_edit.setCalendarPopup(True)

        self.author_combo = QComboBox(self)
        self.author_combo.setEditable(True)
        self.author_combo.addItems([
            "",
            "Jane Smith",
            "Alex Kim",
            "Priya Patel",
            "Miguel Torres",
        ])

        self.source_combo = QComboBox(self)
        self.source_combo.addItems([
            "manual",
            "auto_task",
            "auto_status",
            "auto_comms",
            "import",
        ])

        self.location_edit = QLineEdit(self)
        self.activity_edit = QTextEdit(self)
        self.activity_edit.setPlaceholderText("Describe the activity…")
        self.activity_edit.setMinimumHeight(120)

        self.tags_edit = QLineEdit(self)
        self.tags_edit.setPlaceholderText("tag1, tag2")
        self.critical_check = QCheckBox("Mark as critical", self)

        attach_row = QHBoxLayout()
        self.attach_btn = QPushButton("+ Add File", self)
        self.attach_count = QLabel("Attachments: 0", self)
        attach_row.addWidget(self.attach_btn)
        attach_row.addStretch(1)
        attach_row.addWidget(self.attach_count)

        form.addRow("Time:", self.time_edit)
        form.addRow("Author:", self.author_combo)
        form.addRow("Source:", self.source_combo)
        form.addRow("Location:", self.location_edit)
        form.addRow("Activity:", self.activity_edit)
        form.addRow("Tags:", self.tags_edit)
        form.addRow("", self.critical_check)
        form.addRow("Attachments:", attach_row)
        layout.addLayout(form)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.Save | QDialogButtonBox.Cancel, parent=self
        )
        self.save_new_btn = QPushButton("Save && New", self)
        self.button_box.addButton(self.save_new_btn, QDialogButtonBox.ActionRole)
        layout.addWidget(self.button_box)

        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        self.save_new_btn.clicked.connect(self._on_save_new)

        if self._read_only:
            for widget in (
                self.time_edit,
                self.author_combo,
                self.source_combo,
                self.location_edit,
                self.activity_edit,
                self.tags_edit,
                self.critical_check,
                self.attach_btn,
            ):
                widget.setEnabled(False)
            self.save_new_btn.setEnabled(False)
            ok_btn = self.button_box.button(QDialogButtonBox.Save)
            if ok_btn:
                ok_btn.setText("Close")

    def _apply_entry(self, entry: EntryData) -> None:
        self.time_edit.setDateTime(entry.timestamp)
        idx = self.author_combo.findText(entry.author)
        self.author_combo.setCurrentIndex(max(0, idx))
        src_idx = self.source_combo.findText(entry.source)
        self.source_combo.setCurrentIndex(max(0, src_idx))
        self.location_edit.setText(entry.location)
        self.activity_edit.setPlainText(entry.activity)
        self.tags_edit.setText(", ".join(entry.links))
        self.critical_check.setChecked(entry.critical)
        self.attach_count.setText(f"Attachments: {len(entry.attachments)}")

    def _collect(self) -> bool:
        text = self.activity_edit.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "Validation", "Activity description is required.")
            return False
        tags = [tag.strip() for tag in self.tags_edit.text().split(",") if tag.strip()]
        self._result = EntryData(
            timestamp=self.time_edit.dateTime(),
            author=self.author_combo.currentText(),
            source=self.source_combo.currentText(),
            activity=text,
            location=self.location_edit.text().strip(),
            links=tags,
            attachments=self._original.attachments.copy(),
            autogenerated=self._original.autogenerated,
            critical=self.critical_check.isChecked(),
        )
        return True

    def _on_accept(self) -> None:
        if not self._read_only and not self._collect():
            return
        self.accept()

    def _on_save_new(self) -> None:
        if self._read_only:
            return
        if self._collect():
            self.save_and_new_requested = True
            self.accept()


class PreparedByDialog(QDialog):
    """Dialog capturing Prepared-By signature details."""

    def __init__(
        self,
        name: str | None,
        position: str | None,
        parent: QWidget | None = None,
        *,
        position_hint: str | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("Prepared-By / Sign")
        layout = QFormLayout(self)
        self.name_edit = QLineEdit(name or "", self)
        self.position_edit = QLineEdit(position or "", self)
        if position_hint and not position:
            self.position_edit.setPlaceholderText(position_hint)
        layout.addRow("Name:", self.name_edit)
        layout.addRow("Position:", self.position_edit)

        buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel, self)
        layout.addWidget(buttons)
        buttons.accepted.connect(self._on_accept)
        buttons.rejected.connect(self.reject)

        self.result: tuple[str, str] | None = None

    def _on_accept(self) -> None:
        name = self.name_edit.text().strip()
        position = self.position_edit.text().strip()
        if not name or not position:
            QMessageBox.warning(self, "Validation", "Name and position are required.")
            return
        self.result = (name, position)
        self.accept()


class DraftRowWidget(QWidget):
    """Widget representing a single draft entry in the review tray."""

    viewRequested = Signal()
    acceptRequested = Signal()
    discardRequested = Signal()
    selectionChanged = Signal(bool)

    def __init__(self, draft: DraftEntry, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.draft = draft
        layout = QHBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        self.checkbox = QCheckBox(self)
        self.checkbox.setChecked(draft.selected)
        self.checkbox.toggled.connect(self.selectionChanged)
        self.time_label = QLabel(format_local_time(draft.data.timestamp), self)
        self.time_label.setMinimumWidth(110)
        self.source_label = QLabel(draft.data.source, self)
        self.source_label.setMinimumWidth(90)
        self.summary_label = QLabel(f"“{draft.data.activity}”", self)
        self.summary_label.setWordWrap(True)
        self.summary_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.view_btn = QPushButton("View", self)
        self.accept_btn = QPushButton("Accept", self)
        self.discard_btn = QPushButton("Discard", self)

        for widget in (
            self.checkbox,
            self.time_label,
            self.source_label,
            self.summary_label,
            self.view_btn,
            self.accept_btn,
            self.discard_btn,
        ):
            layout.addWidget(widget)
        layout.addStretch(1)

        self.view_btn.clicked.connect(self.viewRequested)
        self.accept_btn.clicked.connect(self.acceptRequested)
        self.discard_btn.clicked.connect(self.discardRequested)

    def refresh(self) -> None:
        self.checkbox.setChecked(self.draft.selected)
        self.time_label.setText(format_local_time(self.draft.data.timestamp))
        self.source_label.setText(self.draft.data.source)
        self.summary_label.setText(f"“{self.draft.data.activity}”")


class DraftsTrayDialog(QDialog):
    """Review tray dialog for pending drafts."""

    entryAccepted = Signal(DraftEntry)
    entryDiscarded = Signal(DraftEntry)
    acceptAllRequested = Signal(list)

    def __init__(
        self,
        drafts: list[DraftEntry],
        parent: QWidget | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle(f"Review Drafts ({len(drafts)})")
        self._drafts: list[DraftEntry] = [d for d in drafts]
        self._rows: list[DraftRowWidget] = []
        self._build_ui()

    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        self.scroll = QScrollArea(self)
        self.scroll.setWidgetResizable(True)
        container = QWidget(self.scroll)
        self.scroll.setWidget(container)
        self.rows_layout = QVBoxLayout(container)

        for draft in self._drafts:
            self._add_row(draft)

        root.addWidget(self.scroll)

        controls = QHBoxLayout()
        controls.addStretch(1)
        self.accept_all_btn = QPushButton("Accept All", self)
        self.close_btn = QPushButton("Close", self)
        controls.addWidget(self.accept_all_btn)
        controls.addWidget(self.close_btn)
        root.addLayout(controls)

        self.accept_all_btn.clicked.connect(self._on_accept_all)
        self.close_btn.clicked.connect(self.reject)

    def _add_row(self, draft: DraftEntry) -> None:
        row = DraftRowWidget(draft, self)
        row.viewRequested.connect(lambda d=draft, w=row: self._on_view(d, w))
        row.acceptRequested.connect(lambda d=draft: self._on_accept(d))
        row.discardRequested.connect(lambda d=draft: self._on_discard(d))
        row.selectionChanged.connect(lambda state, d=draft: self._on_select(d, state))
        self.rows_layout.addWidget(row)
        self._rows.append(row)

    def _on_view(self, draft: DraftEntry, row: DraftRowWidget) -> None:
        dialog = EntryEditorDialog(draft.data, self, title=f"Review Draft #{draft.draft_id}")
        if dialog.exec() == QDialog.Accepted:
            draft.data = dialog.result.clone()
            row.refresh()

    def _on_accept(self, draft: DraftEntry) -> None:
        self.entryAccepted.emit(draft)
        self._remove_draft(draft)

    def _on_discard(self, draft: DraftEntry) -> None:
        self.entryDiscarded.emit(draft)
        self._remove_draft(draft)

    def _on_select(self, draft: DraftEntry, state: bool) -> None:
        draft.selected = state

    def _on_accept_all(self) -> None:
        selected = [d for d in self._drafts if d.selected]
        if not selected:
            QMessageBox.information(self, "Drafts", "Select drafts to accept.")
            return
        self.acceptAllRequested.emit(selected)
        for draft in list(selected):
            self._remove_draft(draft)

    def _remove_draft(self, draft: DraftEntry) -> None:
        if draft in self._drafts:
            idx = self._drafts.index(draft)
            self._drafts.pop(idx)
            row = self._rows.pop(idx)
            row.setParent(None)
            row.deleteLater()
        self.setWindowTitle(f"Review Drafts ({len(self._drafts)})")
        if not self._drafts:
            self.accept()


class NewLogDialog(QDialog):
    """Dialog for creating or editing an ICS-214 log stream."""

    def __init__(
        self,
        header: LogHeader | None,
        operational_periods: Sequence[tuple[int, str]],
        parent: QWidget | None = None,
        *,
        context: dict[str, Any] | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("ICS 214 Log Details")
        self._context = context or {}
        self._result: dict[str, Any] | None = None
        self._build_ui(operational_periods)
        self._load_defaults(header)

    @property
    def result(self) -> dict[str, Any] | None:
        return self._result

    def _build_ui(self, operational_periods: Sequence[tuple[int, str]]) -> None:
        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.name_edit = QLineEdit(self)
        self.name_edit.setPlaceholderText("e.g., Team G-12 Day Shift")
        form.addRow("Log Name:", self.name_edit)

        self.type_combo = QComboBox(self)
        self.type_combo.addItem("Team", "team")
        self.type_combo.addItem("Section", "section")
        self.type_combo.addItem("Individual", "individual")
        self.type_combo.addItem("Facility", "facility")
        form.addRow("Log Type:", self.type_combo)

        self.section_edit = QLineEdit(self)
        self.section_edit.setPlaceholderText("Section / Unit")
        form.addRow("Section / Unit:", self.section_edit)

        self.op_combo = QComboBox(self)
        for op_number, label in operational_periods:
            self.op_combo.addItem(label, op_number)
        if not operational_periods:
            self.op_combo.addItem("Unassigned", 0)
        form.addRow("Operational Period:", self.op_combo)

        layout.addLayout(form)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        layout.addWidget(buttons)
        buttons.accepted.connect(self._on_accept)
        buttons.rejected.connect(self.reject)

    def _load_defaults(self, header: LogHeader | None) -> None:
        if header is not None:
            self.name_edit.setText(header.log_for_label)
            if header.log_for_type:
                idx = self.type_combo.findData(header.log_for_type)
                if idx >= 0:
                    self.type_combo.setCurrentIndex(idx)
            unit = header.unit_or_resource or header.section or ""
            self.section_edit.setText(unit)
            if header.op_number is not None:
                idx = self.op_combo.findData(header.op_number)
                if idx >= 0:
                    self.op_combo.setCurrentIndex(idx)
            return

        default_type = (self._context.get("default_log_for_type") or "team").lower()
        idx = self.type_combo.findData(default_type)
        if idx >= 0:
            self.type_combo.setCurrentIndex(idx)
        default_ref = self._context.get("default_log_for_ref")
        if default_ref:
            self.section_edit.setText(str(default_ref))
        default_name = self._context.get("default_log_name")
        if default_name:
            self.name_edit.setText(str(default_name))

    def _on_accept(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Validation", "Log name is required.")
            return
        op_number = self.op_combo.currentData()
        if op_number is None:
            op_number = 0
        try:
            op_number_int = int(op_number)
        except (TypeError, ValueError):
            op_number_int = _parse_op_number(op_number)
        section = self.section_edit.text().strip() or None
        self._result = {
            "name": name,
            "kind": self.type_combo.currentData(),
            "section": section,
            "op_number": op_number_int,
        }
        self.accept()


class Ics214ActivityLogPanel(QWidget):
    """Main QWidget implementing the ICS-214 Activity Log workspace."""

    def __init__(
        self,
        incident_id: Any | None = None,
        parent: QWidget | None = None,
        *,
        services: Any | None = None,
        styles: Any | None = None,
        launch_context: dict[str, Any] | None = None,
    ) -> None:
        super().__init__(parent)
        self.styles = styles
        self.launch_context = launch_context or {}
        self.services = services or ics214_services
        self.prepared_by_hint: str | None = self.launch_context.get(
            "default_prepared_by_position"
        )
        self.default_log_type = self.launch_context.get("default_log_for_type")
        self.default_log_ref = self.launch_context.get("default_log_for_ref")
        self.default_log_name = self.launch_context.get("default_log_name")
        self._preferred_stream_id: str | None = None
        # Track whether we've already attempted to match a stream based on the
        # launch context. When a context is supplied we allow one automatic
        # selection attempt; subsequent reloads honour the user's current
        # choice.
        self._context_match_consumed = not bool(self.launch_context)
        self._applying_context = False
        active_incident = incident_context.get_active_incident_id()
        if incident_id is not None:
            self.incident_id = str(incident_id)
        elif active_incident is not None:
            self.incident_id = str(active_incident)
        else:
            self.incident_id = None
        self.header = LogHeader()
        self._current_log_id: str | None = None
        self.entries: list[LogEntry] = []
        self.drafts: list[DraftEntry] = []
        self.known_logs: dict[str, LogHeader] = {}
        self.operational_period_labels: dict[int, str] = {}
        self.operational_period_choices: list[tuple[int, str]] = []
        self.selected_op_number: int | None = None
        self._last_saved: QDateTime | None = None
        self._loading = False
        self._build_ui()
        self._load_initial_data()
        if self.launch_context:
            self.apply_launch_context(self.launch_context)

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        title_row = QHBoxLayout()
        self.title_label = QLabel("ICS 214 — Activity Log", self)
        self.title_label.setStyleSheet("font-size: 20px; font-weight: 600;")
        title_row.addWidget(self.title_label)
        title_row.addStretch(1)
        self.search_edit = QLineEdit(self)
        self.search_edit.setPlaceholderText("Search")
        self.search_edit.textChanged.connect(self._apply_search_filter)
        title_row.addWidget(self.search_edit)
        layout.addLayout(title_row)

        selector_row = QHBoxLayout()
        self.incident_combo = QComboBox(self)
        self.incident_combo.currentIndexChanged.connect(self._on_incident_changed)
        self.op_combo = QComboBox(self)
        self.op_combo.currentTextChanged.connect(self._on_operational_period_changed)
        self.log_combo = QComboBox(self)
        self.log_combo.currentIndexChanged.connect(self._on_log_changed)
        self.new_log_btn = QPushButton("New Log", self)
        self.new_log_btn.clicked.connect(self._open_new_log_dialog)
        selector_row.addWidget(QLabel("Incident:", self))
        selector_row.addWidget(self.incident_combo)
        selector_row.addWidget(QLabel("OP:", self))
        selector_row.addWidget(self.op_combo)
        selector_row.addWidget(QLabel("Log:", self))
        selector_row.addWidget(self.log_combo)
        selector_row.addWidget(self.new_log_btn)
        layout.addLayout(selector_row)

        actions_row = QHBoxLayout()
        self.review_btn = QPushButton("Review Drafts • 0", self)
        self.review_btn.clicked.connect(self._open_drafts_tray)
        self.export_btn = QPushButton("Export", self)
        self.export_menu = self._build_export_menu()
        self.export_btn.setMenu(self.export_menu)
        self.print_btn = QPushButton("Print", self)
        self.print_btn.clicked.connect(self._on_print)
        self.filters_btn = QPushButton("Filters", self)
        self.filters_btn.clicked.connect(self._on_filters)
        actions_row.addWidget(self.review_btn)
        actions_row.addWidget(self.export_btn)
        actions_row.addWidget(self.print_btn)
        actions_row.addStretch(1)
        actions_row.addWidget(self.filters_btn)
        layout.addLayout(actions_row)

        self.header_frame = self._build_header_card()
        layout.addWidget(self.header_frame)

        entries_label = QLabel("Entries", self)
        entries_label.setStyleSheet("font-weight: 600;")
        layout.addWidget(entries_label)

        self.entries_table = QTableWidget(self)
        self.entries_table.setColumnCount(6)
        self.entries_table.setHorizontalHeaderLabels(
            ["#", "Time (Local)", "Activity", "Source", "Links", "⋯"]
        )
        header = self.entries_table.horizontalHeader()
        header.setStretchLastSection(False)
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(5, QHeaderView.ResizeToContents)
        self.entries_table.verticalHeader().setVisible(False)
        self.entries_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.entries_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.entries_table.cellDoubleClicked.connect(self._open_editor_for_row)
        self.entries_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.entries_table.customContextMenuRequested.connect(self._show_table_menu)
        layout.addWidget(self.entries_table)

        self.quick_frame = QFrame(self)
        quick_layout = QHBoxLayout(self.quick_frame)
        quick_layout.setContentsMargins(4, 4, 4, 4)
        quick_layout.addWidget(QLabel("+ Add entry…", self.quick_frame))
        self.quick_time = QDateTimeEdit(self.quick_frame)
        self.quick_time.setDisplayFormat("MM/dd HH:mm")
        self.quick_time.setDateTime(_now_local())
        self.quick_location = QLineEdit(self.quick_frame)
        self.quick_location.setPlaceholderText("Location")
        self.quick_activity = QLineEdit(self.quick_frame)
        self.quick_activity.setPlaceholderText("Activity summary")
        self.quick_add_btn = QPushButton("Add", self.quick_frame)
        self.quick_add_btn.clicked.connect(self._on_quick_add)
        for widget in (
            self.quick_time,
            self.quick_location,
            self.quick_activity,
            self.quick_add_btn,
        ):
            quick_layout.addWidget(widget)
        layout.addWidget(self.quick_frame)

        footer = QHBoxLayout()
        self.rows_label = QLabel("Rows: 0", self)
        footer.addWidget(self.rows_label)
        footer.addStretch(1)
        self.edit_header_btn = QPushButton("Edit Header", self)
        self.edit_header_btn.clicked.connect(self._edit_header)
        self.close_log_btn = QPushButton("Close Log", self)
        self.close_log_btn.clicked.connect(self._close_log)
        self.reopen_btn = QPushButton("Re-open", self)
        self.reopen_btn.clicked.connect(self._reopen_log)
        self.last_saved_label = QLabel("Last saved —", self)
        footer.addWidget(self.edit_header_btn)
        footer.addWidget(self.close_log_btn)
        footer.addWidget(self.reopen_btn)
        footer.addWidget(self.last_saved_label)
        layout.addLayout(footer)

    def _build_header_card(self) -> QWidget:
        frame = QFrame(self)
        frame.setFrameShape(QFrame.StyledPanel)
        grid = QGridLayout(frame)
        grid.setContentsMargins(8, 8, 8, 8)
        grid.setHorizontalSpacing(16)
        self.header_log_for = QLabel(frame)
        self.header_status = QLabel(frame)
        self.header_version = QLabel(frame)
        self.header_prepared = QLabel(frame)
        self.header_start = QLabel(frame)
        self.header_end = QLabel(frame)
        self.header_notes = QLabel(frame)
        self.header_notes.setWordWrap(True)

        grid.addWidget(self.header_log_for, 0, 0)
        grid.addWidget(self.header_status, 0, 1)
        grid.addWidget(self.header_version, 0, 2)
        grid.addWidget(self.header_prepared, 1, 0)
        grid.addWidget(self.header_start, 1, 1)
        grid.addWidget(self.header_end, 1, 2)
        grid.addWidget(self.header_notes, 2, 0, 1, 3)
        return frame

    def _build_export_menu(self) -> QMenu:
        menu = QMenu(self)
        menu.addAction("Export PDF", self._on_export)
        return menu

    def _load_initial_data(self) -> None:
        self._loading = True
        try:
            incidents = self._load_incident_options()
            self.incident_combo.blockSignals(True)
            self.incident_combo.clear()
            for item in incidents:
                self.incident_combo.addItem(item["label"], item["id"])
            self.incident_combo.blockSignals(False)
            if not incidents:
                self.incident_id = None
                self._set_empty_state()
                return
            if self.incident_id:
                idx = self.incident_combo.findData(self.incident_id)
                if idx >= 0:
                    self.incident_combo.setCurrentIndex(idx)
            if self.incident_combo.currentIndex() < 0:
                self.incident_combo.setCurrentIndex(0)
            self.incident_id = self.incident_combo.currentData()
            self._load_operational_period_options()
            self._reload_streams()
        finally:
            self._loading = False

    def _load_incident_options(self) -> list[dict[str, str]]:
        options: list[dict[str, str]] = []
        try:
            records = load_incidents_from_master()
        except Exception as exc:
            logger.exception("Failed to load incidents: %s", exc)
            return options
        for row in records:
            number = getattr(row, "number", None) or getattr(row, "id", None)
            if not number:
                continue
            number_str = str(number)
            name = getattr(row, "name", "")
            label = f"{name} ({number_str})" if name else number_str
            options.append({"id": number_str, "label": label})
        return options

    def _load_operational_period_options(self) -> None:
        self.operational_period_labels = {0: "Unassigned"}
        self.operational_period_choices = [(0, "Unassigned")]
        self.op_combo.blockSignals(True)
        self.op_combo.clear()
        self.op_combo.addItem("Unassigned", 0)
        rows: list[sqlite3.Row] = []
        if self.incident_id:
            db_path = Path("data") / "incidents" / f"{self.incident_id}.db"
            if db_path.exists():
                conn: sqlite3.Connection | None = None
                try:
                    conn = sqlite3.connect(db_path)
                    conn.row_factory = sqlite3.Row
                    cur = conn.cursor()
                    cur.execute(
                        "SELECT name FROM sqlite_master WHERE type='table' AND name='operationalperiods'"
                    )
                    if cur.fetchone():
                        cur.execute(
                            "SELECT id, op_number, start_time, end_time FROM operationalperiods ORDER BY id"
                        )
                        rows = cur.fetchall()
                except Exception as exc:
                    logger.exception(
                        "Failed to load operational periods for %s: %s",
                        self.incident_id,
                        exc,
                    )
                finally:
                    if conn is not None:
                        try:
                            conn.close()
                        except Exception:  # pragma: no cover
                            pass
        for row in rows:
            op_code = row["op_number"]
            op_number = _parse_op_number(op_code)
            label = _format_operational_period_label(
                op_code,
                row["start_time"],
                row["end_time"],
            )
            if op_number not in self.operational_period_labels:
                self.operational_period_labels[op_number] = label
                self.operational_period_choices.append((op_number, label))
                self.op_combo.addItem(label, op_number)
        self.op_combo.blockSignals(False)
        if self.selected_op_number is not None:
            idx = self.op_combo.findData(self.selected_op_number)
            if idx >= 0:
                self.op_combo.setCurrentIndex(idx)
                return
        if self.op_combo.count():
            self.op_combo.setCurrentIndex(0)
        self.selected_op_number = self.op_combo.currentData()

    def _operational_period_label(self, op_number: int | None) -> str:
        if op_number in self.operational_period_labels:
            return self.operational_period_labels[op_number]
        if not op_number:
            return "Unassigned"
        return f"OP {op_number}"

    def _assign_operational_period(self, header: LogHeader) -> None:
        header.operational_period = self._operational_period_label(header.op_number)

    def _header_from_stream(self, stream: Any) -> LogHeader:
        header = LogHeader(
            log_for_type=(stream.kind or "").lower(),
            log_for_label=stream.name or stream.id,
            unit_or_resource=stream.section or "",
            status="OPEN",
            identifier=stream.id,
            incident_id=stream.incident_id,
            stream_id=stream.id,
            op_number=stream.op_number,
            section=stream.section,
            kind=stream.kind,
        )
        self._assign_operational_period(header)
        header.start = _to_qdatetime(stream.created_at)
        header.updated_at = _to_qdatetime(stream.updated_at)
        return header

    def _set_empty_state(self) -> None:
        self.header = LogHeader()
        self._current_log_id = None
        self.entries = []
        self.drafts = []
        self._last_saved = None
        self.log_combo.blockSignals(True)
        self.log_combo.clear()
        self.log_combo.blockSignals(False)
        self._update_header_card()
        self._refresh_table()
        self._update_review_button()
        self._update_footer()

    def _match_context_stream(self, streams: Sequence[Any]) -> str | None:
        if not streams:
            return None
        preferred_type = (self.default_log_type or "").lower().strip()
        preferred_ref = str(self.default_log_ref).strip().lower() if self.default_log_ref else ""
        preferred_name = (
            str(self.default_log_name).strip().lower()
            if self.default_log_name
            else ""
        )
        for stream in streams:
            kind = (getattr(stream, "kind", "") or "").lower()
            section = (getattr(stream, "section", "") or "").strip().lower()
            name = (getattr(stream, "name", "") or "").strip().lower()
            if preferred_type and kind != preferred_type:
                continue
            if preferred_ref and preferred_ref not in {section, name}:
                continue
            if preferred_name and name != preferred_name:
                continue
            return stream.id
        # Fallbacks: try matching by type only or ref only so context can still
        # bias the selection even if the other attribute is missing.
        if preferred_type:
            for stream in streams:
                kind = (getattr(stream, "kind", "") or "").lower()
                if kind == preferred_type:
                    return stream.id
        if preferred_ref:
            for stream in streams:
                section = (getattr(stream, "section", "") or "").strip().lower()
                name = (getattr(stream, "name", "") or "").strip().lower()
                if preferred_ref in {section, name}:
                    return stream.id
        if preferred_name:
            for stream in streams:
                name = (getattr(stream, "name", "") or "").strip().lower()
                if name == preferred_name:
                    return stream.id
        return None

    def _reload_streams(self) -> None:
        previous_id = self.header.stream_id or self._current_log_id
        preferred_id = self._preferred_stream_id
        self.log_combo.blockSignals(True)
        self.log_combo.clear()
        self.known_logs.clear()
        self._current_log_id = None
        if not self.incident_id:
            self.log_combo.blockSignals(False)
            self._set_empty_state()
            return
        try:
            streams = self.services.list_streams(self.incident_id)
        except Exception as exc:
            logger.exception(
                "Failed to load ICS-214 streams for %s: %s",
                self.incident_id,
                exc,
            )
            streams = []
        filtered: list[Any] = []
        for stream in streams:
            if self.selected_op_number not in (None, 0):
                if stream.op_number != self.selected_op_number:
                    continue
            filtered.append(stream)
        for stream in filtered:
            header = self._header_from_stream(stream)
            self.known_logs[stream.id] = header
            self.log_combo.addItem(self._log_display_text(header), stream.id)
        self.log_combo.blockSignals(False)
        if not filtered:
            self._preferred_stream_id = None
            self._set_empty_state()
            return

        target_id: str | None = None
        if preferred_id and any(stream.id == preferred_id for stream in filtered):
            target_id = preferred_id
        if target_id is None and previous_id and any(
            stream.id == previous_id for stream in filtered
        ):
            target_id = previous_id
        if target_id is None and not self._context_match_consumed:
            target_id = self._match_context_stream(filtered)
            self._context_match_consumed = True
        if target_id is None:
            target_id = filtered[0].id

        self._preferred_stream_id = None
        if target_id:
            idx = self.log_combo.findData(target_id)
            if idx >= 0:
                self.log_combo.blockSignals(True)
                self.log_combo.setCurrentIndex(idx)
                self.log_combo.blockSignals(False)
            self._current_log_id = target_id
            self._apply_log_state(target_id)

    def _reload_current_entries(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            self.entries = []
            self._refresh_table()
            return
        try:
            records = self.services.list_entries(
                self.incident_id,
                self.header.stream_id,
            )
        except Exception as exc:
            logger.exception(
                "Failed to load ICS-214 entries for %s/%s: %s",
                self.incident_id,
                self.header.stream_id,
                exc,
            )
            self.entries = []
        else:
            self.entries = [self._entry_from_payload(payload) for payload in records]
        self._refresh_table()

    def _entry_from_payload(self, payload: dict[str, Any]) -> LogEntry:
        timestamp = _to_qdatetime(payload.get("timestamp_utc"))
        tags, location = _split_tags(payload.get("tags"))
        data = EntryData(
            timestamp=timestamp if timestamp.isValid() else _now_local(),
            activity=payload.get("text", ""),
            source=payload.get("source", "manual"),
            author=payload.get("actor_user_id") or "",
            links=tags,
            location=location,
            autogenerated=bool(payload.get("autogenerated")),
            critical=bool(payload.get("critical_flag")),
        )
        return LogEntry(entry_id=str(payload.get("id")), data=data)

    def _apply_search_filter(self, _: str) -> None:
        search = self.search_edit.text().strip().lower()
        for row in range(self.entries_table.rowCount()):
            activity_item = self.entries_table.item(row, 2)
            links_item = self.entries_table.item(row, 4)
            author = ""
            location = ""
            if row < len(self.entries):
                author = self.entries[row].data.author
                location = self.entries[row].data.location
            fragments = [
                activity_item.text() if activity_item else "",
                links_item.text() if links_item else "",
                author,
                location,
            ]
            haystack = " ".join(fragment for fragment in fragments if fragment)
            visible = search in haystack.lower()
            self.entries_table.setRowHidden(row, not visible)
        self._update_rows_label()

    def _refresh_table(self) -> None:
        self.entries.sort(
            key=lambda e: e.data.timestamp.toSecsSinceEpoch()
            if e.data.timestamp.isValid()
            else 0
        )
        self.entries_table.setRowCount(len(self.entries))
        for row, entry in enumerate(self.entries):
            self._populate_row(row, entry)
        self._apply_search_filter(self.search_edit.text())
        self._update_rows_label()

    def _populate_row(self, row: int, entry: LogEntry) -> None:
        data = entry.data
        num_item = QTableWidgetItem(str(row + 1))
        time_item = QTableWidgetItem(format_local_time(data.timestamp))
        activity_lines = [data.activity or "—"]
        if data.location:
            activity_lines.append(f"Location: {data.location}")
        if data.author:
            activity_lines.append(f"Author: {data.author}")
        activity_item = QTableWidgetItem("\n".join(activity_lines))
        source_item = QTableWidgetItem(data.source)
        links_item = QTableWidgetItem(", ".join(data.links) if data.links else "—")
        gear_item = QTableWidgetItem("⋯")
        gear_item.setTextAlignment(Qt.AlignCenter)
        for col, item in enumerate(
            [num_item, time_item, activity_item, source_item, links_item, gear_item]
        ):
            item.setFlags(item.flags() ^ Qt.ItemIsEditable)
            if data.critical:
                item.setBackground(QColor("#ffe5e5"))
            self.entries_table.setItem(row, col, item)

    def _update_header_card(self) -> None:
        header = self.header
        role = header.log_for_type.title() if header.log_for_type else "Log"
        label = header.log_for_label or "—"
        self.header_log_for.setText(f"Log For: {role} — {label}")
        status = header.status or "—"
        self.header_status.setText(f"Status: {status}")
        self.header_version.setText(f"Version: {header.version}")
        prepared = (
            f"Prepared By: {header.prepared_by_name} ({header.prepared_by_position})"
            if header.is_prepared()
            else "Prepared By: —"
        )
        self.header_prepared.setText(prepared)
        self.header_start.setText(f"Start: {format_header_time(header.start)}")
        self.header_end.setText(f"End: {format_header_time(header.end)}")
        notes = header.notes or "—"
        self.header_notes.setText(f"Notes: {notes}")
        has_stream = bool(header.stream_id)
        self.quick_frame.setEnabled(has_stream)
        self.edit_header_btn.setEnabled(has_stream)
        self.close_log_btn.setEnabled(False)
        self.reopen_btn.setEnabled(False)
        self._update_print_button_state()

    def _update_print_button_state(self) -> None:
        self.print_btn.setEnabled(self.header.is_prepared())

    def _update_review_button(self) -> None:
        count = len(self.drafts)
        self.review_btn.setText(f"Review Drafts • {count}")
        self.review_btn.setEnabled(count > 0)

    def _update_footer(self) -> None:
        self._update_rows_label()
        reference = self._last_saved
        if (reference is None or not reference.isValid()) and self.header.updated_at:
            if self.header.updated_at.isValid():
                reference = self.header.updated_at
        if reference and reference.isValid():
            self.last_saved_label.setText(
                f"Last saved {reference.toLocalTime().toString('HH:mm')}"
            )
        else:
            self.last_saved_label.setText("Last saved —")

    def _update_rows_label(self) -> None:
        visible = sum(
            not self.entries_table.isRowHidden(row)
            for row in range(self.entries_table.rowCount())
        )
        total = self.entries_table.rowCount()
        if visible == total:
            self.rows_label.setText(f"Rows: {total}")
        else:
            self.rows_label.setText(f"Rows: {visible} / {total}")

    def _open_editor_for_row(self, row: int, column: int) -> None:
        if row < 0 or row >= len(self.entries):
            return
        if not self.incident_id or not self.header.stream_id:
            return
        entry = self.entries[row]
        dialog = EntryEditorDialog(entry.data, self, title="Edit Entry")
        if dialog.exec() == QDialog.Accepted:
            updated = dialog.result.clone()
            try:
                payload = EntryUpdate(
                    text=updated.activity,
                    timestamp_utc=_qdatetime_to_utc(updated.timestamp),
                    source=updated.source,
                    actor_user_id=updated.author or None,
                    tags=_encode_tags(updated.location, updated.links),
                    critical_flag=updated.critical,
                )
                self.services.update_entry(
                    self.incident_id,
                    entry.entry_id,
                    payload,
                )
            except Exception as exc:
                logger.exception("Failed to update entry %s: %s", entry.entry_id, exc)
                QMessageBox.critical(
                    self,
                    "Update failed",
                    f"Unable to update entry: {exc}",
                )
                return
            self._reload_current_entries()
            self._bump_version()

    def _show_table_menu(self, pos: QPoint) -> None:
        if not self.entries:
            return
        menu = QMenu(self)
        edit_action = menu.addAction("Edit")
        duplicate_action = menu.addAction("Duplicate")
        delete_action = menu.addAction("Delete")
        action = menu.exec(self.entries_table.viewport().mapToGlobal(pos))
        if action == edit_action:
            rows = {index.row() for index in self.entries_table.selectedIndexes()}
            if not rows:
                row = self.entries_table.rowAt(pos.y())
                rows = {row} if row >= 0 else set()
            for row in rows:
                self._open_editor_for_row(row, 0)
        elif action == duplicate_action:
            self._duplicate_selected()
        elif action == delete_action:
            self._delete_selected()

    def _duplicate_selected(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            return
        rows = sorted({index.row() for index in self.entries_table.selectedIndexes()})
        if not rows:
            return
        for row in rows:
            if 0 <= row < len(self.entries):
                entry = self.entries[row]
                try:
                    payload = EntryCreate(
                        text=entry.data.activity,
                        timestamp_utc=_qdatetime_to_utc(entry.data.timestamp),
                        source=entry.data.source,
                        actor_user_id=entry.data.author or None,
                        tags=_encode_tags(entry.data.location, entry.data.links),
                        critical_flag=entry.data.critical,
                    )
                    self.services.add_entry(
                        self.incident_id,
                        self.header.stream_id,
                        payload,
                    )
                except Exception as exc:
                    logger.exception("Failed to duplicate entry %s: %s", entry.entry_id, exc)
                    QMessageBox.warning(
                        self,
                        "Duplicate failed",
                        f"Unable to duplicate entry: {exc}",
                    )
        self._reload_current_entries()
        self._bump_version()

    def _delete_selected(self) -> None:
        if not self.incident_id:
            return
        rows = sorted({index.row() for index in self.entries_table.selectedIndexes()}, reverse=True)
        if not rows:
            return
        for row in rows:
            if 0 <= row < len(self.entries):
                entry_id = self.entries[row].entry_id
                try:
                    self.services.delete_entry(self.incident_id, entry_id)
                except Exception as exc:
                    logger.exception("Failed to delete entry %s: %s", entry_id, exc)
                    QMessageBox.warning(
                        self,
                        "Delete failed",
                        f"Unable to delete entry: {exc}",
                    )
        self._reload_current_entries()
        self._bump_version()

    def _on_quick_add(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            QMessageBox.warning(
                self,
                "Select Log",
                "Create or select a log before adding entries.",
            )
            return
        activity = self.quick_activity.text().strip()
        if not activity:
            QMessageBox.warning(self, "Validation", "Activity description is required.")
            return
        location = self.quick_location.text().strip()
        try:
            payload = EntryCreate(
                text=activity,
                timestamp_utc=_qdatetime_to_utc(self.quick_time.dateTime()),
                source="manual",
                tags=_encode_tags(location, []),
            )
            self.services.add_entry(
                self.incident_id,
                self.header.stream_id,
                payload,
            )
        except Exception as exc:
            logger.exception("Failed to add entry: %s", exc)
            QMessageBox.critical(
                self,
                "Add entry failed",
                f"Unable to add entry: {exc}",
            )
            return
        self.quick_activity.clear()
        self.quick_location.clear()
        self.quick_time.setDateTime(_now_local())
        self._reload_current_entries()
        self._bump_version()

    def _on_incident_changed(self, index: int) -> None:
        if self._loading:
            return
        incident = self.incident_combo.itemData(index)
        self.incident_id = str(incident) if incident else None
        if self.launch_context:
            self._context_match_consumed = False
        if not self._applying_context:
            self._preferred_stream_id = None
        self._load_operational_period_options()
        self._reload_streams()

    def _on_operational_period_changed(self, text: str) -> None:
        if self._loading:
            return
        data = self.op_combo.currentData()
        try:
            self.selected_op_number = int(data) if data is not None else None
        except (TypeError, ValueError):
            self.selected_op_number = _parse_op_number(data)
        if not self._applying_context:
            self._preferred_stream_id = None
        if self.launch_context:
            self._context_match_consumed = False
        self._reload_streams()

    def _open_drafts_tray(self) -> None:
        if not self.drafts:
            QMessageBox.information(self, "Drafts", "No drafts available.")
            return
        dialog = DraftsTrayDialog([draft for draft in self.drafts], self)
        dialog.entryAccepted.connect(self._accept_draft)
        dialog.entryDiscarded.connect(self._discard_draft)
        dialog.acceptAllRequested.connect(self._accept_all_drafts)
        dialog.exec()

    def _accept_draft(self, draft: DraftEntry) -> None:
        if not self.incident_id or not self.header.stream_id:
            return
        try:
            payload = EntryCreate(
                text=draft.data.activity,
                timestamp_utc=_qdatetime_to_utc(draft.data.timestamp),
                source=draft.data.source,
                actor_user_id=draft.data.author or None,
                tags=_encode_tags(draft.data.location, draft.data.links),
                critical_flag=draft.data.critical,
            )
            self.services.add_entry(
                self.incident_id,
                self.header.stream_id,
                payload,
            )
        except Exception as exc:
            logger.exception("Failed to accept draft: %s", exc)
            QMessageBox.warning(
                self,
                "Draft error",
                f"Unable to accept draft: {exc}",
            )
            return
        self._remove_draft(draft)
        self._reload_current_entries()
        self._bump_version()

    def _discard_draft(self, draft: DraftEntry) -> None:
        self._remove_draft(draft)
        self._update_review_button()

    def _accept_all_drafts(self, drafts: list[DraftEntry]) -> None:
        if not drafts:
            return
        if not self.incident_id or not self.header.stream_id:
            return
        added = False
        for draft in drafts:
            try:
                payload = EntryCreate(
                    text=draft.data.activity,
                    timestamp_utc=_qdatetime_to_utc(draft.data.timestamp),
                    source=draft.data.source,
                    actor_user_id=draft.data.author or None,
                    tags=_encode_tags(draft.data.location, draft.data.links),
                    critical_flag=draft.data.critical,
                )
                self.services.add_entry(
                    self.incident_id,
                    self.header.stream_id,
                    payload,
                )
            except Exception as exc:
                logger.exception("Failed to accept draft: %s", exc)
                QMessageBox.warning(
                    self,
                    "Draft error",
                    f"Unable to accept draft: {exc}",
                )
                continue
            self._remove_draft(draft)
            added = True
        if added:
            self._reload_current_entries()
            self._bump_version()

    def _remove_draft(self, draft: DraftEntry) -> None:
        for existing in list(self.drafts):
            if existing.draft_id == draft.draft_id:
                self.drafts.remove(existing)
                break
        self._update_review_button()

    def _close_log(self) -> None:
        QMessageBox.information(
            self,
            "Not implemented",
            "Closing logs is not yet implemented.",
        )

    def _reopen_log(self) -> None:
        QMessageBox.information(
            self,
            "Not implemented",
            "Log reopening is not yet implemented.",
        )

    def _edit_header(self) -> None:
        if not self.header.stream_id or not self.incident_id:
            QMessageBox.information(
                self,
                "No Log",
                "Select a log before editing the header.",
            )
            return
        dialog = NewLogDialog(
            self.header.clone(),
            self.operational_period_choices,
            self,
            context=self.launch_context,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            data = dialog.result
            try:
                payload = StreamUpdate(
                    name=data["name"],
                    op_number=data["op_number"],
                    kind=data["kind"],
                    section=data["section"],
                )
                stream = self.services.update_stream(
                    self.incident_id,
                    self.header.stream_id,
                    payload,
                )
            except Exception as exc:
                logger.exception(
                    "Failed to update stream %s: %s",
                    self.header.stream_id,
                    exc,
                )
                QMessageBox.critical(
                    self,
                    "Update failed",
                    f"Unable to update log header: {exc}",
                )
                return
            if stream:
                new_header = self._header_from_stream(stream)
                new_header.prepared_by_name = self.header.prepared_by_name
                new_header.prepared_by_position = self.header.prepared_by_position
                new_header.notes = self.header.notes
                self._set_header(new_header)
                if self.header.stream_id:
                    self._preferred_stream_id = self.header.stream_id
                self._context_match_consumed = True
                self._reload_streams()

    def _open_new_log_dialog(self) -> None:
        if not self.incident_id:
            QMessageBox.warning(
                self,
                "Select Incident",
                "Select an incident before creating a log.",
            )
            return
        dialog = NewLogDialog(
            None,
            self.operational_period_choices,
            self,
            context=self.launch_context,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            data = dialog.result
            try:
                payload = StreamCreate(
                    incident_id=self.incident_id,
                    name=data["name"],
                    op_number=data["op_number"],
                    kind=data["kind"],
                    section=data["section"],
                )
                stream = self.services.create_stream(payload)
            except Exception as exc:
                logger.exception("Failed to create stream: %s", exc)
                QMessageBox.critical(
                    self,
                    "Create failed",
                    f"Unable to create log: {exc}",
                )
                return
            self._preferred_stream_id = stream.id
            self._context_match_consumed = True
            self._reload_streams()

    def _on_log_changed(self, index: int) -> None:
        if index < 0:
            return
        log_id = self.log_combo.itemData(index)
        if not log_id:
            self._set_empty_state()
            return
        log_id = str(log_id)
        if self._current_log_id == log_id:
            return
        self._current_log_id = log_id
        # Once the user intentionally selects a log we stop trying to
        # auto-select based on launch context.
        self._context_match_consumed = True
        self._apply_log_state(log_id)

    def _apply_log_state(self, log_id: str) -> None:
        header = self.known_logs.get(log_id)
        if header is None and self.incident_id:
            try:
                streams = self.services.list_streams(self.incident_id)
            except Exception:
                streams = []
            for stream in streams:
                if stream.id == log_id:
                    header = self._header_from_stream(stream)
                    self.known_logs[log_id] = header
                    break
        if header is None:
            self._set_empty_state()
            return
        self._current_log_id = log_id
        self.header = header.clone()
        self._assign_operational_period(self.header)
        if self.header.op_number is not None:
            idx = self.op_combo.findData(self.header.op_number)
            if idx >= 0:
                self.op_combo.blockSignals(True)
                self.op_combo.setCurrentIndex(idx)
                self.op_combo.blockSignals(False)
                self.selected_op_number = self.header.op_number
        self._last_saved = (
            self.header.updated_at
            if self.header.updated_at and self.header.updated_at.isValid()
            else None
        )
        self.drafts = []
        self._update_header_card()
        self._reload_current_entries()
        self._update_review_button()
        self._update_footer()
        self._update_known_log()

    def _update_known_log(self) -> None:
        stream_id = self.header.stream_id
        if not stream_id:
            return
        header_clone = self.header.clone()
        self._assign_operational_period(header_clone)
        self.known_logs[stream_id] = header_clone
        idx = self.log_combo.findData(stream_id)
        if idx >= 0:
            self.log_combo.setItemText(idx, self._log_display_text(header_clone))

    def _log_display_text(self, header: LogHeader) -> str:
        label = header.log_for_label or header.stream_id or "Log"
        role = header.log_for_type.title() if header.log_for_type else ""
        if role and not label.lower().startswith(role.lower()):
            display_name = f"{role} — {label}"
        else:
            display_name = label
        period = header.operational_period or self._operational_period_label(
            header.op_number
        )
        return f"{display_name} ({period})" if period else display_name

    def _on_export(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            QMessageBox.information(self, "Export", "Select a log to export.")
            return
        try:
            export = self.services.export_stream(
                self.incident_id,
                self.header.stream_id,
                ExportRequest(include_auto=True),
            )
        except Exception as exc:
            logger.exception("Failed to export log %s: %s", self.header.stream_id, exc)
            QMessageBox.critical(
                self,
                "Export failed",
                f"Unable to export log: {exc}",
            )
            return
        raw_path = getattr(export, "file_path", "")
        if raw_path:
            try:
                display_path = str(Path(raw_path).resolve())
            except Exception:  # pragma: no cover - defensive
                display_path = str(raw_path)
        else:
            display_path = "unknown location"
        QMessageBox.information(
            self,
            "Export ready",
            f"Export generated at\n{display_path}",
        )

    def _on_print(self) -> None:
        if not self.header.is_prepared():
            if not self._open_prepared_by_dialog():
                return
        QMessageBox.information(
            self,
            "Print",
            "PDF rendering pipeline placeholder — will generate ICS-214 PDF.",
        )

    def _on_filters(self) -> None:
        QMessageBox.information(
            self,
            "Filters",
            "Filter dialog placeholder — source toggles and time range forthcoming.",
        )

    def _open_prepared_by_dialog(self) -> bool:
        dialog = PreparedByDialog(
            self.header.prepared_by_name,
            self.header.prepared_by_position,
            self,
            position_hint=self.prepared_by_hint,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            name, position = dialog.result
            self.header.prepared_by_name = name
            self.header.prepared_by_position = position
            self._bump_version()
            return True
        return False

    def _set_header(self, header: LogHeader) -> None:
        new_header = header.clone()
        self._assign_operational_period(new_header)
        self.header = new_header
        stream_id = new_header.stream_id
        if stream_id:
            idx = self.log_combo.findData(stream_id)
            if idx >= 0:
                display = self._log_display_text(new_header)
                if self.log_combo.itemText(idx) != display:
                    self.log_combo.setItemText(idx, display)
                if self.log_combo.currentData() != stream_id:
                    self.log_combo.blockSignals(True)
                    self.log_combo.setCurrentIndex(idx)
                    self.log_combo.blockSignals(False)
        self._current_log_id = stream_id
        self._last_saved = (
            new_header.updated_at
            if new_header.updated_at and new_header.updated_at.isValid()
            else None
        )
        self._update_header_card()
        self._update_known_log()
        self._update_footer()

    def _bump_version(self, update_timestamp: bool = True) -> None:
        if self.header.stream_id:
            self.header.version += 1
        if update_timestamp:
            now = _now_local()
            self.header.updated_at = now
            self._last_saved = now
            self._update_footer()
        else:
            self._update_footer()
        self._update_header_card()
        self._update_known_log()

    def apply_launch_context(self, context: dict[str, Any]) -> None:
        self._applying_context = True
        try:
            self.launch_context = context or {}
            self.prepared_by_hint = context.get(
                "default_prepared_by_position", self.prepared_by_hint
            )
            self.default_log_type = context.get("default_log_for_type", self.default_log_type)
            self.default_log_ref = context.get("default_log_for_ref", self.default_log_ref)
            self.default_log_name = context.get("default_log_name", self.default_log_name)
            direct_stream = context.get("default_stream_id") or context.get("default_log_id")
            self._preferred_stream_id = str(direct_stream) if direct_stream else None
            # Re-run context-based selection for the next stream reload.
            self._context_match_consumed = False
            pin_incident = context.get("pin_incident")
            if pin_incident is not None:
                self.incident_combo.setEnabled(not pin_incident)
            pin_op = context.get("pin_operational_period")
            if pin_op is not None:
                self.op_combo.setEnabled(not pin_op)
            default_incident = context.get("default_incident_id")
            if default_incident:
                idx = self.incident_combo.findData(str(default_incident))
                if idx >= 0:
                    self.incident_combo.setCurrentIndex(idx)
            default_op = context.get("default_operational_period")
            if default_op is not None:
                try:
                    op_number = int(default_op)
                except (TypeError, ValueError):
                    op_number = _parse_op_number(default_op)
                idx = self.op_combo.findData(op_number)
                if idx >= 0:
                    self.op_combo.setCurrentIndex(idx)
            filters = context.get("default_filters")
            if filters and not self.search_edit.text():
                text_filter = filters.get("search") or ""
                if text_filter:
                    self.search_edit.setText(str(text_filter))
            if self.incident_id and not self._loading:
                self._reload_streams()
        finally:
            self._applying_context = False
