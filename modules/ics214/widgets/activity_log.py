"""QtWidgets implementation for the redesigned ICS-214 Activity Log module."""
from __future__ import annotations

import json
import logging
import re
import sqlite3
from dataclasses import dataclass, field, replace
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Sequence
from uuid import uuid4

from PySide6.QtCore import QDate, QDateTime, QTime, QPoint, Qt, Signal, QSize
from PySide6.QtGui import QColor
from PySide6.QtWidgets import (
    QAbstractItemView,
    QCheckBox,
    QComboBox,
    QDateTimeEdit,
    QDialog,
    QDialogButtonBox,
    QFormLayout,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMenu,
    QMessageBox,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from models.incidentlist import load_incidents_from_master

from .. import services as ics214_services
from ..schemas import (
    EntryCreate,
    EntryUpdate,
    StreamCreate,
    StreamUpdate,
    ExportRequest,
)
from utils import incident_context

logger = logging.getLogger(__name__)


SUBJECT_REF_PATTERN = re.compile(r"^(team|section|individual|facility):(.+)$", re.IGNORECASE)

DEFAULT_SECTION_SUBJECTS: list[dict[str, str]] = [
    {"ref": "section:command", "label": "Command"},
    {"ref": "section:operations", "label": "Operations"},
    {"ref": "section:planning", "label": "Planning"},
    {"ref": "section:logistics", "label": "Logistics"},
    {"ref": "section:finance_admin", "label": "Finance / Admin"},
    {"ref": "section:intel", "label": "Intelligence"},
    {"ref": "section:liaison", "label": "Liaison"},
    {"ref": "section:public_information", "label": "Public Information"},
    {"ref": "section:medical_safety", "label": "Medical & Safety"},
    {"ref": "section:communications", "label": "Communications"},
]


def _now_local() -> QDateTime:
    dt = QDateTime.currentDateTime()
    dt.setTimeSpec(Qt.LocalTime)
    return dt


def _unique_ordered(values: Sequence[str]) -> list[str]:
    seen: set[str] = set()
    ordered: list[str] = []
    for value in values:
        if not value:
            continue
        normalized = value.strip().lower()
        if not normalized or normalized in seen:
            continue
        seen.add(normalized)
        ordered.append(value)
    return ordered


def _parse_subject_section(value: Any | None) -> tuple[str | None, str | None, str | None, str | None]:
    """Decode stored subject metadata from the stream.section field."""

    if value is None:
        return None, None, None, None
    raw = str(value).strip()
    if not raw:
        return None, None, None, None
    if raw.startswith("{"):
        try:
            payload = json.loads(raw)
        except Exception:
            return None, None, raw, None
        category = payload.get("category") or payload.get("kind") or payload.get("type")
        category = category.lower() if isinstance(category, str) else None
        ref = payload.get("ref")
        label = payload.get("label") or payload.get("name")
        description = payload.get("description") or payload.get("details")
        return category, ref, label, description
    match = SUBJECT_REF_PATTERN.match(raw)
    if match:
        category = match.group(1).lower()
        identifier = match.group(2).strip()
        ref = f"{category}:{identifier}"
        pretty = identifier.replace("_", " ").replace("-", " ")
        label = pretty.title() if pretty and pretty.isalpha() else identifier
        return category, ref, label, None
    return None, None, raw, None


@dataclass
class EntryData:
    """Container for editable ICS-214 entry attributes."""

    timestamp: QDateTime = field(default_factory=_now_local)
    author: str = ""
    source: str = "manual"
    activity: str = ""
    location: str = ""
    links: list[str] = field(default_factory=list)
    attachments: list[str] = field(default_factory=list)
    autogenerated: bool = False
    critical: bool = False

    def clone(self) -> "EntryData":
        return replace(
            self,
            timestamp=QDateTime(self.timestamp),
            links=list(self.links),
            attachments=list(self.attachments),
        )


@dataclass
class LogEntry:
    """Saved entry rendered in the main log table."""

    entry_id: str
    data: EntryData


@dataclass
class DraftEntry:
    """Auto-generated draft awaiting review."""

    draft_id: int
    data: EntryData
    selected: bool = True


@dataclass
class LogHeader:
    """Metadata describing the active ICS-214 log."""

    log_for_type: str = ""
    log_for_label: str = ""
    unit_or_resource: str = ""
    operational_period: str = ""
    status: str | None = None
    version: int = 1
    prepared_by_name: str | None = None
    prepared_by_position: str | None = None
    start: QDateTime = field(default_factory=_now_local)
    end: QDateTime | None = None
    notes: str = ""
    identifier: str = field(default_factory=lambda: uuid4().hex)
    incident_id: str | None = None
    stream_id: str | None = None
    op_number: int | None = None
    section: str | None = None
    kind: str | None = None
    subject_ref: str | None = None
    subject_label: str | None = None
    subject_description: str | None = None
    updated_at: QDateTime | None = None

    def clone(self) -> "LogHeader":
        cp = replace(self)
        if self.start.isValid():
            cp.start = QDateTime(self.start)
        if self.end is not None and self.end.isValid():
            cp.end = QDateTime(self.end)
        if self.updated_at is not None and self.updated_at.isValid():
            cp.updated_at = QDateTime(self.updated_at)
        return cp

    def is_prepared(self) -> bool:
        return bool(self.prepared_by_name and self.prepared_by_position)


def format_local_time(dt: QDateTime) -> str:
    if not dt.isValid():
        return "—"
    return dt.toLocalTime().toString("HH:mm MM/dd")


def format_header_time(dt: QDateTime | None) -> str:
    if dt is None or not dt.isValid():
        return "—"
    return dt.toLocalTime().toString("yyyy-MM-dd HH:mm")


def _to_qdatetime(value: datetime | str | None) -> QDateTime:
    if value is None:
        return QDateTime()
    if isinstance(value, str):
        try:
            value = datetime.fromisoformat(value)
        except ValueError:
            return QDateTime()
    if not isinstance(value, datetime):
        return QDateTime()
    if value.tzinfo is None:
        value = value.replace(tzinfo=timezone.utc)
    else:
        value = value.astimezone(timezone.utc)
    qdate = QDate(value.year, value.month, value.day)
    qtime = QTime(value.hour, value.minute, value.second, int(value.microsecond / 1000))
    return QDateTime(qdate, qtime, Qt.UTC)


def _qdatetime_to_utc(dt: QDateTime) -> datetime:
    if not dt.isValid():
        return datetime.utcnow()
    as_utc = dt.toUTC()
    qdate = as_utc.date()
    qtime = as_utc.time()
    return datetime(
        qdate.year(),
        qdate.month(),
        qdate.day(),
        qtime.hour(),
        qtime.minute(),
        qtime.second(),
        qtime.msec() * 1000,
    )


def _split_tags(tags: Sequence[Any] | None) -> tuple[list[str], str]:
    clean: list[str] = []
    location = ""
    for raw in tags or []:
        tag = str(raw)
        if tag.startswith("loc:"):
            if not location:
                location = tag[4:].strip()
        elif tag:
            clean.append(tag)
    return clean, location


def _encode_tags(location: str, tags: Sequence[str]) -> list[str]:
    encoded = [tag for tag in tags if tag]
    if location:
        encoded.append(f"loc:{location}")
    return encoded


def _parse_op_number(value: str | int | None) -> int:
    if value is None:
        return 0
    if isinstance(value, int):
        return value
    digits = "".join(ch for ch in str(value) if ch.isdigit())
    return int(digits) if digits else 0


def _format_timestamp_label(value: str | None) -> str:
    if not value:
        return ""
    try:
        dt = datetime.fromisoformat(value)
    except ValueError:
        return value
    return dt.strftime("%Y-%m-%d %H:%M")


def _format_operational_period_label(code: str | None, start: str | None, end: str | None) -> str:
    label = code or "OP"
    start_txt = _format_timestamp_label(start)
    end_txt = _format_timestamp_label(end)
    if start_txt and end_txt:
        return f"{label} ({start_txt} – {end_txt})"
    if start_txt:
        return f"{label} ({start_txt})"
    return label


class EntryEditorDialog(QDialog):
    """Rich editor dialog for ICS-214 entries."""

    def __init__(
        self,
        entry: EntryData | None = None,
        parent: QWidget | None = None,
        *,
        title: str | None = None,
        read_only: bool = False,
    ) -> None:
        super().__init__(parent)
        self._original = entry.clone() if entry else EntryData()
        self._result = self._original.clone()
        self._read_only = read_only
        self.save_and_new_requested = False
        self.setWindowTitle(title or "Edit Entry")
        self._build_ui()
        self._apply_entry(self._original)

    @property
    def result(self) -> EntryData:
        return self._result

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)

        form = QFormLayout()
        self.time_edit = QDateTimeEdit(self)
        self.time_edit.setDisplayFormat("yyyy-MM-dd HH:mm")
        self.time_edit.setCalendarPopup(True)

        self.author_combo = QComboBox(self)
        self.author_combo.setEditable(True)
        self.author_combo.addItems([
            "",
            "Jane Smith",
            "Alex Kim",
            "Priya Patel",
            "Miguel Torres",
        ])

        self.source_combo = QComboBox(self)
        self.source_combo.addItems([
            "manual",
            "auto_task",
            "auto_status",
            "auto_comms",
            "import",
        ])

        self.location_edit = QLineEdit(self)
        self.activity_edit = QTextEdit(self)
        self.activity_edit.setPlaceholderText("Describe the activity…")
        self.activity_edit.setMinimumHeight(120)

        self.tags_edit = QLineEdit(self)
        self.tags_edit.setPlaceholderText("tag1, tag2")
        self.critical_check = QCheckBox("Mark as critical", self)

        attach_row = QHBoxLayout()
        self.attach_btn = QPushButton("+ Add File", self)
        self.attach_count = QLabel("Attachments: 0", self)
        attach_row.addWidget(self.attach_btn)
        attach_row.addStretch(1)
        attach_row.addWidget(self.attach_count)

        form.addRow("Time:", self.time_edit)
        form.addRow("Author:", self.author_combo)
        form.addRow("Source:", self.source_combo)
        form.addRow("Location:", self.location_edit)
        form.addRow("Activity:", self.activity_edit)
        form.addRow("Tags:", self.tags_edit)
        form.addRow("", self.critical_check)
        form.addRow("Attachments:", attach_row)
        layout.addLayout(form)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.Save | QDialogButtonBox.Cancel, parent=self
        )
        self.save_new_btn = QPushButton("Save && New", self)
        self.button_box.addButton(self.save_new_btn, QDialogButtonBox.ActionRole)
        layout.addWidget(self.button_box)

        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        self.save_new_btn.clicked.connect(self._on_save_new)

        if self._read_only:
            for widget in (
                self.time_edit,
                self.author_combo,
                self.source_combo,
                self.location_edit,
                self.activity_edit,
                self.tags_edit,
                self.critical_check,
                self.attach_btn,
            ):
                widget.setEnabled(False)
            self.save_new_btn.setEnabled(False)
            ok_btn = self.button_box.button(QDialogButtonBox.Save)
            if ok_btn:
                ok_btn.setText("Close")

    def _apply_entry(self, entry: EntryData) -> None:
        self.time_edit.setDateTime(entry.timestamp)
        idx = self.author_combo.findText(entry.author)
        self.author_combo.setCurrentIndex(max(0, idx))
        src_idx = self.source_combo.findText(entry.source)
        self.source_combo.setCurrentIndex(max(0, src_idx))
        self.location_edit.setText(entry.location)
        self.activity_edit.setPlainText(entry.activity)
        self.tags_edit.setText(", ".join(entry.links))
        self.critical_check.setChecked(entry.critical)
        self.attach_count.setText(f"Attachments: {len(entry.attachments)}")

    def _collect(self) -> bool:
        text = self.activity_edit.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "Validation", "Activity description is required.")
            return False
        tags = [tag.strip() for tag in self.tags_edit.text().split(",") if tag.strip()]
        self._result = EntryData(
            timestamp=self.time_edit.dateTime(),
            author=self.author_combo.currentText(),
            source=self.source_combo.currentText(),
            activity=text,
            location=self.location_edit.text().strip(),
            links=tags,
            attachments=self._original.attachments.copy(),
            autogenerated=self._original.autogenerated,
            critical=self.critical_check.isChecked(),
        )
        return True

    def _on_accept(self) -> None:
        if not self._read_only and not self._collect():
            return
        self.accept()

    def _on_save_new(self) -> None:
        if self._read_only:
            return
        if self._collect():
            self.save_and_new_requested = True
            self.accept()


class PreparedByDialog(QDialog):
    """Dialog capturing Prepared-By signature details."""

    def __init__(
        self,
        name: str | None,
        position: str | None,
        parent: QWidget | None = None,
        *,
        position_hint: str | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("Prepared-By / Sign")
        layout = QFormLayout(self)
        self.name_edit = QLineEdit(name or "", self)
        self.position_edit = QLineEdit(position or "", self)
        if position_hint and not position:
            self.position_edit.setPlaceholderText(position_hint)
        layout.addRow("Name:", self.name_edit)
        layout.addRow("Position:", self.position_edit)

        buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel, self)
        layout.addWidget(buttons)
        buttons.accepted.connect(self._on_accept)
        buttons.rejected.connect(self.reject)

        self.result: tuple[str, str] | None = None

    def _on_accept(self) -> None:
        name = self.name_edit.text().strip()
        position = self.position_edit.text().strip()
        if not name or not position:
            QMessageBox.warning(self, "Validation", "Name and position are required.")
            return
        self.result = (name, position)
        self.accept()


class DraftRowWidget(QWidget):
    """Widget representing a single draft entry in the review tray."""

    viewRequested = Signal()
    acceptRequested = Signal()
    discardRequested = Signal()
    selectionChanged = Signal(bool)

    def __init__(self, draft: DraftEntry, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.draft = draft
        layout = QHBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        self.checkbox = QCheckBox(self)
        self.checkbox.setChecked(draft.selected)
        self.checkbox.toggled.connect(self.selectionChanged)
        self.time_label = QLabel(format_local_time(draft.data.timestamp), self)
        self.time_label.setMinimumWidth(110)
        self.source_label = QLabel(draft.data.source, self)
        self.source_label.setMinimumWidth(90)
        self.summary_label = QLabel(f"“{draft.data.activity}”", self)
        self.summary_label.setWordWrap(True)
        self.summary_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.view_btn = QPushButton("View", self)
        self.accept_btn = QPushButton("Accept", self)
        self.discard_btn = QPushButton("Discard", self)

        for widget in (
            self.checkbox,
            self.time_label,
            self.source_label,
            self.summary_label,
            self.view_btn,
            self.accept_btn,
            self.discard_btn,
        ):
            layout.addWidget(widget)
        layout.addStretch(1)

        self.view_btn.clicked.connect(self.viewRequested)
        self.accept_btn.clicked.connect(self.acceptRequested)
        self.discard_btn.clicked.connect(self.discardRequested)

    def refresh(self) -> None:
        self.checkbox.setChecked(self.draft.selected)
        self.time_label.setText(format_local_time(self.draft.data.timestamp))
        self.source_label.setText(self.draft.data.source)
        self.summary_label.setText(f"“{self.draft.data.activity}”")


class DraftsTrayDialog(QDialog):
    """Review tray dialog for pending drafts."""

    entryAccepted = Signal(DraftEntry)
    entryDiscarded = Signal(DraftEntry)
    acceptAllRequested = Signal(list)

    def __init__(
        self,
        drafts: list[DraftEntry],
        parent: QWidget | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle(f"Review Drafts ({len(drafts)})")
        self._drafts: list[DraftEntry] = [d for d in drafts]
        self._rows: list[DraftRowWidget] = []
        self._build_ui()

    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        self.scroll = QScrollArea(self)
        self.scroll.setWidgetResizable(True)
        container = QWidget(self.scroll)
        self.scroll.setWidget(container)
        self.rows_layout = QVBoxLayout(container)

        for draft in self._drafts:
            self._add_row(draft)

        root.addWidget(self.scroll)

        controls = QHBoxLayout()
        controls.addStretch(1)
        self.accept_all_btn = QPushButton("Accept All", self)
        self.close_btn = QPushButton("Close", self)
        controls.addWidget(self.accept_all_btn)
        controls.addWidget(self.close_btn)
        root.addLayout(controls)

        self.accept_all_btn.clicked.connect(self._on_accept_all)
        self.close_btn.clicked.connect(self.reject)

    def _add_row(self, draft: DraftEntry) -> None:
        row = DraftRowWidget(draft, self)
        row.viewRequested.connect(lambda d=draft, w=row: self._on_view(d, w))
        row.acceptRequested.connect(lambda d=draft: self._on_accept(d))
        row.discardRequested.connect(lambda d=draft: self._on_discard(d))
        row.selectionChanged.connect(lambda state, d=draft: self._on_select(d, state))
        self.rows_layout.addWidget(row)
        self._rows.append(row)

    def _on_view(self, draft: DraftEntry, row: DraftRowWidget) -> None:
        dialog = EntryEditorDialog(draft.data, self, title=f"Review Draft #{draft.draft_id}")
        if dialog.exec() == QDialog.Accepted:
            draft.data = dialog.result.clone()
            row.refresh()

    def _on_accept(self, draft: DraftEntry) -> None:
        self.entryAccepted.emit(draft)
        self._remove_draft(draft)

    def _on_discard(self, draft: DraftEntry) -> None:
        self.entryDiscarded.emit(draft)
        self._remove_draft(draft)

    def _on_select(self, draft: DraftEntry, state: bool) -> None:
        draft.selected = state

    def _on_accept_all(self) -> None:
        selected = [d for d in self._drafts if d.selected]
        if not selected:
            QMessageBox.information(self, "Drafts", "Select drafts to accept.")
            return
        self.acceptAllRequested.emit(selected)
        for draft in list(selected):
            self._remove_draft(draft)

    def _remove_draft(self, draft: DraftEntry) -> None:
        if draft in self._drafts:
            idx = self._drafts.index(draft)
            self._drafts.pop(idx)
            row = self._rows.pop(idx)
            row.setParent(None)
            row.deleteLater()
        self.setWindowTitle(f"Review Drafts ({len(self._drafts)})")
        if not self._drafts:
            self.accept()


class NewLogDialog(QDialog):
    """Dialog for creating or editing an ICS-214 log stream."""

    def __init__(
        self,
        header: LogHeader | None,
        operational_periods: Sequence[tuple[int, str]],
        parent: QWidget | None = None,
        *,
        subject_options: dict[str, list[dict[str, Any]]] | None = None,
        context: dict[str, Any] | None = None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("ICS 214 Log Details")
        self._context = context or {}
        base_options = subject_options or {}
        self._subject_options: dict[str, list[dict[str, Any]]] = {
            "team": [dict(item) for item in base_options.get("team", [])],
            "section": [dict(item) for item in base_options.get("section", [])],
            "individual": [dict(item) for item in base_options.get("individual", [])],
            "facility": [dict(item) for item in base_options.get("facility", [])],
        }
        if not self._subject_options["section"]:
            self._subject_options["section"] = [dict(item) for item in DEFAULT_SECTION_SUBJECTS]
        self._result: dict[str, Any] | None = None
        self.selected_kind: str | None = None
        self.selected_ref: str | None = None
        self._all_subject_items: list[QListWidgetItem] = []
        self._build_ui(operational_periods)
        self._load_defaults(header)
        if self.category_list.currentRow() < 0 and self.category_list.count():
            self.category_list.setCurrentRow(0)
        self.resize(700, 520)

    @property
    def result(self) -> dict[str, Any] | None:
        return self._result

    def _build_ui(self, operational_periods: Sequence[tuple[int, str]]) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        layout.addWidget(
            QLabel("Choose who this log is for, then confirm the details below.", self)
        )

        selector_layout = QHBoxLayout()
        self.category_list = QListWidget(self)
        self.category_list.setMinimumWidth(180)
        for label, kind in [
            ("Teams", "team"),
            ("Sections", "section"),
            ("Personnel", "individual"),
            ("Facilities", "facility"),
        ]:
            item = QListWidgetItem(label)
            item.setData(Qt.UserRole, kind)
            self.category_list.addItem(item)
        self.category_list.currentItemChanged.connect(self._on_category_changed)
        selector_layout.addWidget(self.category_list, 1)

        right_layout = QVBoxLayout()
        self.subject_search = QLineEdit(self)
        self.subject_search.setPlaceholderText("Search subjects…")
        self.subject_search.textChanged.connect(self._filter_subjects)
        right_layout.addWidget(self.subject_search)

        self.subject_list = QListWidget(self)
        self.subject_list.setSelectionMode(QListWidget.SingleSelection)
        self.subject_list.itemSelectionChanged.connect(self._on_subject_selected)
        right_layout.addWidget(self.subject_list, 1)
        selector_layout.addLayout(right_layout, 2)
        layout.addLayout(selector_layout)

        form = QFormLayout()
        self.subject_display = QLineEdit(self)
        self.subject_display.setReadOnly(True)
        self.subject_display.setPlaceholderText("Select a subject from the list")
        form.addRow("Subject:", self.subject_display)

        self.name_edit = QLineEdit(self)
        self.name_edit.setPlaceholderText("e.g., Team G-12 Day Shift")
        form.addRow("Log Name:", self.name_edit)

        self.op_combo = QComboBox(self)
        for op_number, label in operational_periods:
            self.op_combo.addItem(label, op_number)
        if not operational_periods:
            self.op_combo.addItem("Unassigned", 0)
        form.addRow("Operational Period:", self.op_combo)

        layout.addLayout(form)

        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        buttons.accepted.connect(self._on_accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def _select_category(self, kind: str | None) -> None:
        target = (kind or "team").lower()
        for row in range(self.category_list.count()):
            item = self.category_list.item(row)
            if (item.data(Qt.UserRole) or "").lower() == target:
                self.category_list.setCurrentRow(row)
                return
        if self.category_list.count():
            self.category_list.setCurrentRow(0)

    def _populate_subjects(self, kind: str | None) -> None:
        current_kind = (kind or "team").lower()
        self.selected_kind = current_kind
        self.subject_list.blockSignals(True)
        self.subject_list.clear()
        self._all_subject_items = []
        manual_item = QListWidgetItem("Manual entry…")
        manual_item.setData(Qt.UserRole, {"kind": current_kind, "manual": True})
        manual_item.setToolTip("Enter a custom subject for this log")
        self.subject_list.addItem(manual_item)
        self._all_subject_items.append(manual_item)
        options = self._subject_options.get(current_kind, [])
        has_options = False
        for option in options:
            label = str(option.get("label") or option.get("ref") or "").strip()
            if not label:
                continue
            item = QListWidgetItem(label)
            meta = {
                "kind": current_kind,
                "ref": option.get("ref"),
                "label": label,
                "description": option.get("description"),
                "manual": False,
                "extra": option,
            }
            item.setData(Qt.UserRole, meta)
            search_blob = " ".join(
                filter(
                    None,
                    [
                        label.lower(),
                        str(option.get("ref", "")).lower(),
                        str(option.get("description", "")).lower(),
                    ],
                )
            )
            item.setData(Qt.UserRole + 1, search_blob)
            if option.get("description"):
                item.setToolTip(str(option["description"]))
            self.subject_list.addItem(item)
            self._all_subject_items.append(item)
            has_options = True
        if not has_options:
            placeholder = QListWidgetItem("No linked records available")
            placeholder.setFlags(placeholder.flags() & ~Qt.ItemIsSelectable & ~Qt.ItemIsEnabled)
            placeholder.setData(Qt.UserRole, {"kind": current_kind, "placeholder": True})
            self.subject_list.addItem(placeholder)
            self._all_subject_items.append(placeholder)
        self.subject_list.blockSignals(False)
        self.subject_list.clearSelection()
        self.subject_search.blockSignals(True)
        self.subject_search.clear()
        self.subject_search.setEnabled(has_options)
        self.subject_search.blockSignals(False)
        self.subject_display.clear()
        self.subject_display.setPlaceholderText("Select a subject from the list")
        self.subject_display.setReadOnly(True)
        self.selected_ref = None
        if not has_options:
            self.subject_list.setCurrentRow(0)

    def _filter_subjects(self, text: str) -> None:
        pattern = text.strip().lower()
        for item in self._all_subject_items:
            meta = item.data(Qt.UserRole) or {}
            if meta.get("placeholder"):
                item.setHidden(bool(pattern))
                continue
            if meta.get("manual"):
                item.setHidden(False)
                continue
            search_blob = item.data(Qt.UserRole + 1) or ""
            item.setHidden(bool(pattern) and pattern not in search_blob)

    def _on_category_changed(
        self,
        current: QListWidgetItem | None,
        previous: QListWidgetItem | None = None,
    ) -> None:
        kind = (current.data(Qt.UserRole) if current else None) or "team"
        self._populate_subjects(str(kind))

    def _on_subject_selected(self) -> None:
        item = self.subject_list.currentItem()
        if not item:
            return
        meta = item.data(Qt.UserRole) or {}
        if meta.get("placeholder"):
            self.subject_list.clearSelection()
            return
        kind = meta.get("kind") or self.selected_kind or "team"
        self.selected_kind = str(kind)
        if meta.get("manual"):
            self.selected_ref = None
            self.subject_display.setReadOnly(False)
            if not self.subject_display.text():
                self.subject_display.setPlaceholderText("Enter subject name")
            self.subject_display.setToolTip("")
            self.subject_display.setFocus()
            return
        label = meta.get("label") or item.text()
        self.selected_ref = meta.get("ref")
        self.subject_display.setReadOnly(True)
        self.subject_display.setText(label)
        self.subject_display.setToolTip(meta.get("description") or "")
        if not self.name_edit.text().strip():
            self.name_edit.setText(label)

    def _select_subject_by_ref(self, ref: str | None) -> bool:
        if not ref:
            return False
        target = ref.strip().lower()
        if not target:
            return False
        for row in range(self.subject_list.count()):
            item = self.subject_list.item(row)
            meta = item.data(Qt.UserRole) or {}
            meta_ref = (meta.get("ref") or "").strip().lower()
            if meta_ref == target:
                self.subject_list.setCurrentRow(row)
                return True
        return False

    def _select_subject_by_label(self, label: str | None) -> bool:
        if not label:
            return False
        target = label.strip().lower()
        if not target:
            return False
        for row in range(self.subject_list.count()):
            item = self.subject_list.item(row)
            meta = item.data(Qt.UserRole) or {}
            text = (item.text() or "").strip().lower()
            meta_label = (meta.get("label") or "").strip().lower()
            if target in {text, meta_label}:
                self.subject_list.setCurrentRow(row)
                return True
        return False

    def _load_defaults(self, header: LogHeader | None) -> None:
        if header is not None:
            kind = (header.kind or header.log_for_type or "").lower() or "team"
            self._select_category(kind)
            subject_selected = False
            if header.subject_ref and self._select_subject_by_ref(header.subject_ref):
                subject_selected = True
            elif header.subject_label and self._select_subject_by_label(header.subject_label):
                subject_selected = True
            if not subject_selected and header.subject_label:
                self.subject_display.setText(header.subject_label)
                self.subject_display.setReadOnly(False)
                self.selected_kind = kind
                self.selected_ref = None
            if header.log_for_label:
                self.name_edit.setText(header.log_for_label)
            if header.op_number is not None:
                idx = self.op_combo.findData(header.op_number)
                if idx >= 0:
                    self.op_combo.setCurrentIndex(idx)
            return
        default_type = (self._context.get("default_log_for_type") or "team").lower()
        default_ref = self._context.get("default_log_for_ref")
        default_name = self._context.get("default_log_name")
        self._select_category(default_type)
        subject_selected = False
        if default_ref:
            ref_candidate = str(default_ref).strip()
            if ref_candidate:
                if ":" not in ref_candidate:
                    ref_candidate = f"{default_type}:{ref_candidate}"
                subject_selected = self._select_subject_by_ref(ref_candidate)
                if not subject_selected:
                    subject_selected = self._select_subject_by_label(str(default_ref))
        if not subject_selected and default_name:
            subject_selected = self._select_subject_by_label(str(default_name))
        if default_name and not self.name_edit.text().strip():
            self.name_edit.setText(str(default_name))
        if not subject_selected and default_name:
            self.subject_display.setText(str(default_name))
            self.subject_display.setReadOnly(False)
            self.selected_kind = default_type
            self.selected_ref = None

    def _on_accept(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Validation", "Log name is required.")
            return
        kind = self.selected_kind or ""
        if not kind and self.category_list.currentItem():
            kind = str(self.category_list.currentItem().data(Qt.UserRole) or "").lower()
        if not kind:
            QMessageBox.warning(self, "Validation", "Choose a category for the log.")
            return
        label = self.subject_display.text().strip()
        if not label:
            QMessageBox.warning(self, "Validation", "Select or enter a subject.")
            return
        raw_op = self.op_combo.currentData()
        if raw_op is None:
            op_number = 0
        else:
            try:
                op_number = int(raw_op)
            except (TypeError, ValueError):
                op_number = _parse_op_number(raw_op)
        subject_meta = {"category": kind, "label": label}
        if self.selected_ref:
            subject_meta["ref"] = self.selected_ref
        section_value = json.dumps(subject_meta, ensure_ascii=False)
        self._result = {
            "name": name,
            "kind": kind,
            "section": section_value,
            "op_number": op_number,
            "subject_meta": subject_meta,
        }
        self.accept()


class Ics214ActivityLogPanel(QWidget):
    """Main QWidget implementing the ICS-214 Activity Log workspace."""

    def __init__(
        self,
        incident_id: Any | None = None,
        parent: QWidget | None = None,
        *,
        services: Any | None = None,
        styles: Any | None = None,
        launch_context: dict[str, Any] | None = None,
    ) -> None:
        super().__init__(parent)
        self.styles = styles
        self.launch_context = launch_context or {}
        self.services = services or ics214_services
        self.prepared_by_hint: str | None = self.launch_context.get(
            "default_prepared_by_position"
        )
        self.default_log_type = self.launch_context.get("default_log_for_type")
        self.default_log_ref = self.launch_context.get("default_log_for_ref")
        self.default_log_name = self.launch_context.get("default_log_name")
        self._preferred_stream_id: str | None = None
        # Track whether we've already attempted to match a stream based on the
        # launch context. When a context is supplied we allow one automatic
        # selection attempt; subsequent reloads honour the user's current
        # choice.
        self._context_match_consumed = not bool(self.launch_context)
        self._applying_context = False
        active_incident = incident_context.get_active_incident_id()
        if incident_id is not None:
            self.incident_id = str(incident_id)
        elif active_incident is not None:
            self.incident_id = str(active_incident)
        else:
            self.incident_id = None
        self.header = LogHeader()
        self._current_log_id: str | None = None
        self.entries: list[LogEntry] = []
        self.drafts: list[DraftEntry] = []
        self.known_logs: dict[str, LogHeader] = {}
        self.operational_period_labels: dict[int, str] = {}
        self.operational_period_choices: list[tuple[int, str]] = []
        self.selected_op_number: int | None = None
        self._last_saved: QDateTime | None = None
        self._loading = False
        self._incident_label_cache: dict[str, str] = {}
        self.subject_options: dict[str, list[dict[str, Any]]] = {
            "team": [],
            "section": [],
            "individual": [],
            "facility": [],
        }
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._build_ui()
        self.resize(self.sizeHint())
        self._load_initial_data()
        if self.launch_context:
            self.apply_launch_context(self.launch_context)

    def sizeHint(self) -> QSize:  # type: ignore[override]
        return QSize(1280, 840)

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        title_row = QHBoxLayout()
        self.title_label = QLabel("ICS 214 — Activity Log", self)
        self.title_label.setStyleSheet("font-size: 20px; font-weight: 600;")
        title_row.addWidget(self.title_label)
        title_row.addStretch(1)
        self.search_edit = QLineEdit(self)
        self.search_edit.setPlaceholderText("Search")
        self.search_edit.textChanged.connect(self._apply_search_filter)
        title_row.addWidget(self.search_edit)
        layout.addLayout(title_row)

        selector_row = QHBoxLayout()
        self.incident_label = QLabel("—", self)
        self.incident_label.setObjectName("incidentLabel")
        try:
            self.incident_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        except Exception:  # pragma: no cover - PySide safety
            pass
        self.op_combo = QComboBox(self)
        self.op_combo.currentTextChanged.connect(self._on_operational_period_changed)
        self.log_combo = QComboBox(self)
        self.log_combo.currentIndexChanged.connect(self._on_log_changed)
        self.new_log_btn = QPushButton("New Log", self)
        self.new_log_btn.clicked.connect(self._open_new_log_dialog)
        selector_row.addWidget(QLabel("Incident:", self))
        selector_row.addWidget(self.incident_label)
        selector_row.addWidget(QLabel("OP:", self))
        selector_row.addWidget(self.op_combo)
        selector_row.addWidget(QLabel("Log:", self))
        selector_row.addWidget(self.log_combo)
        selector_row.addWidget(self.new_log_btn)
        layout.addLayout(selector_row)

        actions_row = QHBoxLayout()
        self.review_btn = QPushButton("Review Drafts • 0", self)
        self.review_btn.clicked.connect(self._open_drafts_tray)
        self.export_btn = QPushButton("Export", self)
        self.export_menu = self._build_export_menu()
        self.export_btn.setMenu(self.export_menu)
        self.print_btn = QPushButton("Print", self)
        self.print_btn.clicked.connect(self._on_print)
        self.filters_btn = QPushButton("Filters", self)
        self.filters_btn.clicked.connect(self._on_filters)
        actions_row.addWidget(self.review_btn)
        actions_row.addWidget(self.export_btn)
        actions_row.addWidget(self.print_btn)
        actions_row.addStretch(1)
        actions_row.addWidget(self.filters_btn)
        layout.addLayout(actions_row)

        self.header_frame = self._build_header_card()
        layout.addWidget(self.header_frame)

        entries_label = QLabel("Entries", self)
        entries_label.setStyleSheet("font-weight: 600;")
        layout.addWidget(entries_label)

        self.entries_table = QTableWidget(self)
        self.entries_table.setSizePolicy(
            QSizePolicy.Expanding, QSizePolicy.Expanding
        )
        self.entries_table.setColumnCount(6)
        self.entries_table.setHorizontalHeaderLabels(
            ["#", "Time (Local)", "Activity", "Source", "Links", "⋯"]
        )
        header = self.entries_table.horizontalHeader()
        header.setStretchLastSection(False)
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(5, QHeaderView.ResizeToContents)
        self.entries_table.verticalHeader().setVisible(False)
        self.entries_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.entries_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.entries_table.cellDoubleClicked.connect(self._open_editor_for_row)
        self.entries_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.entries_table.customContextMenuRequested.connect(self._show_table_menu)
        layout.addWidget(self.entries_table, 1)

        self.quick_frame = QFrame(self)
        self.quick_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        quick_layout = QHBoxLayout(self.quick_frame)
        quick_layout.setContentsMargins(4, 4, 4, 4)
        quick_layout.addWidget(QLabel("+ Add entry…", self.quick_frame))
        self.quick_time = QDateTimeEdit(self.quick_frame)
        self.quick_time.setDisplayFormat("MM/dd HH:mm")
        self.quick_time.setDateTime(_now_local())
        self.quick_location = QLineEdit(self.quick_frame)
        self.quick_location.setPlaceholderText("Location")
        self.quick_activity = QLineEdit(self.quick_frame)
        self.quick_activity.setPlaceholderText("Activity summary")
        self.quick_add_btn = QPushButton("Add", self.quick_frame)
        self.quick_add_btn.clicked.connect(self._on_quick_add)
        for widget in (
            self.quick_time,
            self.quick_location,
            self.quick_activity,
            self.quick_add_btn,
        ):
            quick_layout.addWidget(widget)
        layout.addWidget(self.quick_frame)

        footer = QHBoxLayout()
        self.rows_label = QLabel("Rows: 0", self)
        footer.addWidget(self.rows_label)
        footer.addStretch(1)
        self.edit_header_btn = QPushButton("Edit Header", self)
        self.edit_header_btn.clicked.connect(self._edit_header)
        self.close_log_btn = QPushButton("Close Log", self)
        self.close_log_btn.clicked.connect(self._close_log)
        self.reopen_btn = QPushButton("Re-open", self)
        self.reopen_btn.clicked.connect(self._reopen_log)
        self.last_saved_label = QLabel("Last saved —", self)
        footer.addWidget(self.edit_header_btn)
        footer.addWidget(self.close_log_btn)
        footer.addWidget(self.reopen_btn)
        footer.addWidget(self.last_saved_label)
        layout.addLayout(footer)
        layout.setStretch(5, 1)

    def _build_header_card(self) -> QWidget:
        frame = QFrame(self)
        frame.setFrameShape(QFrame.StyledPanel)
        grid = QGridLayout(frame)
        grid.setContentsMargins(8, 8, 8, 8)
        grid.setHorizontalSpacing(16)
        self.header_log_for = QLabel(frame)
        self.header_status = QLabel(frame)
        self.header_version = QLabel(frame)
        self.header_prepared = QLabel(frame)
        self.header_start = QLabel(frame)
        self.header_end = QLabel(frame)
        self.header_notes = QLabel(frame)
        self.header_notes.setWordWrap(True)

        grid.addWidget(self.header_log_for, 0, 0)
        grid.addWidget(self.header_status, 0, 1)
        grid.addWidget(self.header_version, 0, 2)
        grid.addWidget(self.header_prepared, 1, 0)
        grid.addWidget(self.header_start, 1, 1)
        grid.addWidget(self.header_end, 1, 2)
        grid.addWidget(self.header_notes, 2, 0, 1, 3)
        return frame

    def _build_export_menu(self) -> QMenu:
        menu = QMenu(self)
        menu.addAction("Export PDF", self._on_export)
        return menu

    def _load_subject_options(self) -> None:
        for key in self.subject_options.keys():
            self.subject_options[key] = []
        if not self.incident_id:
            self.subject_options["section"] = [dict(item) for item in DEFAULT_SECTION_SUBJECTS]
            return
        try:
            options = self.services.list_subject_options(self.incident_id)
        except AttributeError:
            options = {}
        except Exception as exc:  # pragma: no cover - defensive
            logger.exception(
                "Failed to load ICS-214 subject options for incident %s: %s",
                self.incident_id,
                exc,
            )
            options = {}
        for key in self.subject_options.keys():
            values = options.get(key, []) if isinstance(options, dict) else []
            self.subject_options[key] = [dict(value) for value in values]
        if not self.subject_options.get("section"):
            self.subject_options["section"] = [dict(item) for item in DEFAULT_SECTION_SUBJECTS]
        for header in self.known_logs.values():
            self._register_subject_option(
                (header.kind or header.log_for_type or "").lower(),
                header.subject_ref,
                header.subject_label,
                header.subject_description,
            )
        if self.header.subject_ref and self.header.subject_label:
            self._register_subject_option(
                (self.header.kind or self.header.log_for_type or "").lower(),
                self.header.subject_ref,
                self.header.subject_label,
                self.header.subject_description,
            )

    def _register_subject_option(
        self,
        kind: str | None,
        ref: str | None,
        label: str | None,
        description: str | None = None,
    ) -> None:
        if not kind or not ref or not label:
            return
        bucket = self.subject_options.setdefault(kind, [])
        for entry in bucket:
            if entry.get("ref") == ref:
                if not entry.get("label"):
                    entry["label"] = label
                if description and not entry.get("description"):
                    entry["description"] = description
                return
        record = {"ref": ref, "label": label}
        if description:
            record["description"] = description
        bucket.append(record)

    def _load_initial_data(self) -> None:
        self._loading = True
        try:
            self._refresh_incident_label()
            if not self.incident_id:
                self._set_empty_state()
                return
            self._load_subject_options()
            self._load_operational_period_options()
            self._reload_streams()
        finally:
            self._loading = False

    def _load_incident_options(self) -> list[dict[str, str]]:
        options: list[dict[str, str]] = []
        self._incident_label_cache.clear()
        try:
            records = load_incidents_from_master()
        except Exception as exc:
            logger.debug("Failed to load incidents: %s", exc)
            return options
        for row in records:
            number = getattr(row, "number", None) or getattr(row, "id", None)
            if not number:
                continue
            number_str = str(number)
            name = getattr(row, "name", "")
            label = f"{name} ({number_str})" if name else number_str
            options.append({"id": number_str, "label": label})
            self._incident_label_cache[number_str] = label
        return options

    def _refresh_incident_label(self, forced_id: str | None = None) -> None:
        options = self._load_incident_options()
        target_id = forced_id
        if target_id is None:
            target_id = self.incident_id or incident_context.get_active_incident_id()
        if target_id:
            target_str = str(target_id)
            self.incident_id = target_str
            label = self._incident_label_cache.get(target_str) or target_str
        elif options:
            choice = options[0]
            self.incident_id = choice["id"]
            label = choice["label"]
        else:
            self.incident_id = None
            label = "No active incident"
        self.incident_label.setText(label or "—")

    def _set_incident(self, incident_id: str | None) -> None:
        normalized = str(incident_id) if incident_id is not None else None
        same = normalized == self.incident_id
        self._refresh_incident_label(normalized)
        if self._loading:
            return
        if same and self.incident_id:
            return
        if self.incident_id:
            self._load_subject_options()
            self._load_operational_period_options()
            self._reload_streams()
        else:
            self._set_empty_state()

    def _load_operational_period_options(self) -> None:
        self.operational_period_labels = {0: "Unassigned"}
        self.operational_period_choices = [(0, "Unassigned")]
        self.op_combo.blockSignals(True)
        self.op_combo.clear()
        self.op_combo.addItem("Unassigned", 0)
        rows: list[sqlite3.Row] = []
        if self.incident_id:
            db_path = Path("data") / "incidents" / f"{self.incident_id}.db"
            if db_path.exists():
                conn: sqlite3.Connection | None = None
                try:
                    conn = sqlite3.connect(db_path)
                    conn.row_factory = sqlite3.Row
                    cur = conn.cursor()
                    cur.execute(
                        "SELECT name FROM sqlite_master WHERE type='table' AND name='operationalperiods'"
                    )
                    if cur.fetchone():
                        cur.execute(
                            "SELECT id, op_number, start_time, end_time FROM operationalperiods ORDER BY id"
                        )
                        rows = cur.fetchall()
                except Exception as exc:
                    logger.exception(
                        "Failed to load operational periods for %s: %s",
                        self.incident_id,
                        exc,
                    )
                finally:
                    if conn is not None:
                        try:
                            conn.close()
                        except Exception:  # pragma: no cover
                            pass
        for row in rows:
            op_code = row["op_number"]
            op_number = _parse_op_number(op_code)
            label = _format_operational_period_label(
                op_code,
                row["start_time"],
                row["end_time"],
            )
            if op_number not in self.operational_period_labels:
                self.operational_period_labels[op_number] = label
                self.operational_period_choices.append((op_number, label))
                self.op_combo.addItem(label, op_number)
        self.op_combo.blockSignals(False)
        if self.selected_op_number is not None:
            idx = self.op_combo.findData(self.selected_op_number)
            if idx >= 0:
                self.op_combo.setCurrentIndex(idx)
                return
        if self.op_combo.count():
            self.op_combo.setCurrentIndex(0)
        self.selected_op_number = self.op_combo.currentData()

    def _operational_period_label(self, op_number: int | None) -> str:
        if op_number in self.operational_period_labels:
            return self.operational_period_labels[op_number]
        if not op_number:
            return "Unassigned"
        return f"OP {op_number}"

    def _assign_operational_period(self, header: LogHeader) -> None:
        header.operational_period = self._operational_period_label(header.op_number)

    def _header_from_stream(self, stream: Any) -> LogHeader:
        stream_kind = (getattr(stream, "kind", "") or "").lower()
        category, subject_ref, subject_label, subject_description = _parse_subject_section(
            getattr(stream, "section", None)
        )
        if category and not stream_kind:
            stream_kind = category
        header = LogHeader(
            log_for_type=stream_kind,
            log_for_label=getattr(stream, "name", None) or getattr(stream, "id", ""),
            unit_or_resource=subject_label
            or getattr(stream, "section", None)
            or "",
            status="OPEN",
            identifier=stream.id,
            incident_id=stream.incident_id,
            stream_id=stream.id,
            op_number=stream.op_number,
            section=getattr(stream, "section", None),
            kind=stream_kind,
            subject_ref=subject_ref,
            subject_label=subject_label,
            subject_description=subject_description,
        )
        self._assign_operational_period(header)
        header.start = _to_qdatetime(stream.created_at)
        header.updated_at = _to_qdatetime(stream.updated_at)
        if subject_ref and subject_label:
            self._register_subject_option(stream_kind or category, subject_ref, subject_label, subject_description)
        return header

    def _set_empty_state(self) -> None:
        self.header = LogHeader()
        self._current_log_id = None
        self.entries = []
        self.drafts = []
        self._last_saved = None
        self.log_combo.blockSignals(True)
        self.log_combo.clear()
        self.log_combo.blockSignals(False)
        self._update_header_card()
        self._refresh_table()
        self._update_review_button()
        self._update_footer()

    def _match_context_stream(self, streams: Sequence[Any]) -> str | None:
        if not streams:
            return None
        preferred_type = (self.default_log_type or "").lower().strip()
        preferred_ref = str(self.default_log_ref).strip().lower() if self.default_log_ref else ""
        preferred_name = (
            str(self.default_log_name).strip().lower()
            if self.default_log_name
            else ""
        )
        for stream in streams:
            kind = (getattr(stream, "kind", "") or "").lower()
            category, subject_ref, subject_label, _ = _parse_subject_section(
                getattr(stream, "section", None)
            )
            if category and not kind:
                kind = category
            name = (getattr(stream, "name", "") or "").strip().lower()
            section_raw = (getattr(stream, "section", "") or "").strip().lower()
            candidates = {
                value
                for value in {
                    section_raw,
                    name,
                    subject_label.strip().lower() if subject_label else "",
                    subject_ref.strip().lower() if subject_ref else "",
                }
                if value
            }
            if preferred_type and kind != preferred_type:
                continue
            if preferred_ref and preferred_ref not in candidates:
                continue
            if preferred_name and preferred_name not in candidates:
                continue
            return stream.id
        # Fallbacks: try matching by type only or ref only so context can still
        # bias the selection even if the other attribute is missing.
        if preferred_type:
            for stream in streams:
                kind = (getattr(stream, "kind", "") or "").lower()
                if kind == preferred_type:
                    return stream.id
        if preferred_ref:
            for stream in streams:
                category, subject_ref, subject_label, _ = _parse_subject_section(
                    getattr(stream, "section", None)
                )
                section_raw = (getattr(stream, "section", "") or "").strip().lower()
                name = (getattr(stream, "name", "") or "").strip().lower()
                candidates = {
                    value
                    for value in {
                        section_raw,
                        name,
                        subject_ref.strip().lower() if subject_ref else "",
                        subject_label.strip().lower() if subject_label else "",
                    }
                    if value
                }
                if preferred_ref in candidates:
                    return stream.id
        if preferred_name:
            for stream in streams:
                category, subject_ref, subject_label, _ = _parse_subject_section(
                    getattr(stream, "section", None)
                )
                name = (getattr(stream, "name", "") or "").strip().lower()
                candidates = {
                    value
                    for value in {
                        name,
                        subject_label.strip().lower() if subject_label else "",
                        subject_ref.strip().lower() if subject_ref else "",
                    }
                    if value
                }
                if preferred_name in candidates:
                    return stream.id
        return None

    def _reload_streams(self) -> None:
        previous_id = self.header.stream_id or self._current_log_id
        preferred_id = self._preferred_stream_id
        self.log_combo.blockSignals(True)
        self.log_combo.clear()
        self.known_logs.clear()
        self._current_log_id = None
        if not self.incident_id:
            self.log_combo.blockSignals(False)
            self._set_empty_state()
            return
        try:
            streams = self.services.list_streams(self.incident_id)
        except Exception as exc:
            logger.exception(
                "Failed to load ICS-214 streams for %s: %s",
                self.incident_id,
                exc,
            )
            streams = []
        filtered: list[Any] = []
        for stream in streams:
            if self.selected_op_number not in (None, 0):
                if stream.op_number != self.selected_op_number:
                    continue
            filtered.append(stream)
        for stream in filtered:
            header = self._header_from_stream(stream)
            self.known_logs[stream.id] = header
            self.log_combo.addItem(self._log_display_text(header), stream.id)
        self.log_combo.blockSignals(False)
        if not filtered:
            self._preferred_stream_id = None
            self._set_empty_state()
            return

        target_id: str | None = None
        if preferred_id and any(stream.id == preferred_id for stream in filtered):
            target_id = preferred_id
        if target_id is None and previous_id and any(
            stream.id == previous_id for stream in filtered
        ):
            target_id = previous_id
        if target_id is None and not self._context_match_consumed:
            target_id = self._match_context_stream(filtered)
            self._context_match_consumed = True
        if target_id is None:
            target_id = filtered[0].id

        self._preferred_stream_id = None
        if target_id:
            idx = self.log_combo.findData(target_id)
            if idx >= 0:
                self.log_combo.blockSignals(True)
                self.log_combo.setCurrentIndex(idx)
                self.log_combo.blockSignals(False)
            self._current_log_id = target_id
            self._apply_log_state(target_id)

    def _reload_current_entries(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            self.entries = []
            self._refresh_table()
            return
        try:
            records = self.services.list_entries(
                self.incident_id,
                self.header.stream_id,
            )
        except Exception as exc:
            logger.exception(
                "Failed to load ICS-214 entries for %s/%s: %s",
                self.incident_id,
                self.header.stream_id,
                exc,
            )
            self.entries = []
        else:
            self.entries = [self._entry_from_payload(payload) for payload in records]
        self._refresh_table()

    def _entry_from_payload(self, payload: dict[str, Any]) -> LogEntry:
        timestamp = _to_qdatetime(payload.get("timestamp_utc"))
        tags, location = _split_tags(payload.get("tags"))
        data = EntryData(
            timestamp=timestamp if timestamp.isValid() else _now_local(),
            activity=payload.get("text", ""),
            source=payload.get("source", "manual"),
            author=payload.get("actor_user_id") or "",
            links=tags,
            location=location,
            autogenerated=bool(payload.get("autogenerated")),
            critical=bool(payload.get("critical_flag")),
        )
        return LogEntry(entry_id=str(payload.get("id")), data=data)

    def _apply_search_filter(self, _: str) -> None:
        search = self.search_edit.text().strip().lower()
        for row in range(self.entries_table.rowCount()):
            activity_item = self.entries_table.item(row, 2)
            links_item = self.entries_table.item(row, 4)
            author = ""
            location = ""
            if row < len(self.entries):
                author = self.entries[row].data.author
                location = self.entries[row].data.location
            fragments = [
                activity_item.text() if activity_item else "",
                links_item.text() if links_item else "",
                author,
                location,
            ]
            haystack = " ".join(fragment for fragment in fragments if fragment)
            visible = search in haystack.lower()
            self.entries_table.setRowHidden(row, not visible)
        self._update_rows_label()

    def _refresh_table(self) -> None:
        self.entries.sort(
            key=lambda e: e.data.timestamp.toSecsSinceEpoch()
            if e.data.timestamp.isValid()
            else 0
        )
        self.entries_table.setRowCount(len(self.entries))
        for row, entry in enumerate(self.entries):
            self._populate_row(row, entry)
        self._apply_search_filter(self.search_edit.text())
        self._update_rows_label()

    def _populate_row(self, row: int, entry: LogEntry) -> None:
        data = entry.data
        num_item = QTableWidgetItem(str(row + 1))
        time_item = QTableWidgetItem(format_local_time(data.timestamp))
        activity_lines = [data.activity or "—"]
        if data.location:
            activity_lines.append(f"Location: {data.location}")
        if data.author:
            activity_lines.append(f"Author: {data.author}")
        activity_item = QTableWidgetItem("\n".join(activity_lines))
        source_item = QTableWidgetItem(data.source)
        links_item = QTableWidgetItem(", ".join(data.links) if data.links else "—")
        gear_item = QTableWidgetItem("⋯")
        gear_item.setTextAlignment(Qt.AlignCenter)
        for col, item in enumerate(
            [num_item, time_item, activity_item, source_item, links_item, gear_item]
        ):
            item.setFlags(item.flags() ^ Qt.ItemIsEditable)
            if data.critical:
                item.setBackground(QColor("#ffe5e5"))
            self.entries_table.setItem(row, col, item)

    def _update_header_card(self) -> None:
        header = self.header
        parts = _unique_ordered(
            [
                header.log_for_type.title() if header.log_for_type else "",
                header.log_for_label or "",
                header.subject_label or "",
            ]
        )
        display = " — ".join(parts) if parts else "Log"
        self.header_log_for.setText(f"Log For: {display}")
        tooltip_parts = [p for p in [header.subject_label, header.subject_description] if p]
        self.header_log_for.setToolTip(" — ".join(tooltip_parts) if tooltip_parts else "")
        status = header.status or "—"
        self.header_status.setText(f"Status: {status}")
        self.header_version.setText(f"Version: {header.version}")
        prepared = (
            f"Prepared By: {header.prepared_by_name} ({header.prepared_by_position})"
            if header.is_prepared()
            else "Prepared By: —"
        )
        self.header_prepared.setText(prepared)
        self.header_start.setText(f"Start: {format_header_time(header.start)}")
        self.header_end.setText(f"End: {format_header_time(header.end)}")
        notes = header.notes or "—"
        self.header_notes.setText(f"Notes: {notes}")
        has_stream = bool(header.stream_id)
        self.quick_frame.setEnabled(has_stream)
        self.edit_header_btn.setEnabled(has_stream)
        self.close_log_btn.setEnabled(False)
        self.reopen_btn.setEnabled(False)
        self._update_print_button_state()

    def _update_print_button_state(self) -> None:
        self.print_btn.setEnabled(self.header.is_prepared())

    def _update_review_button(self) -> None:
        count = len(self.drafts)
        self.review_btn.setText(f"Review Drafts • {count}")
        self.review_btn.setEnabled(count > 0)

    def _update_footer(self) -> None:
        self._update_rows_label()
        reference = self._last_saved
        if (reference is None or not reference.isValid()) and self.header.updated_at:
            if self.header.updated_at.isValid():
                reference = self.header.updated_at
        if reference and reference.isValid():
            self.last_saved_label.setText(
                f"Last saved {reference.toLocalTime().toString('HH:mm')}"
            )
        else:
            self.last_saved_label.setText("Last saved —")

    def _update_rows_label(self) -> None:
        visible = sum(
            not self.entries_table.isRowHidden(row)
            for row in range(self.entries_table.rowCount())
        )
        total = self.entries_table.rowCount()
        if visible == total:
            self.rows_label.setText(f"Rows: {total}")
        else:
            self.rows_label.setText(f"Rows: {visible} / {total}")

    def _open_editor_for_row(self, row: int, column: int) -> None:
        if row < 0 or row >= len(self.entries):
            return
        if not self.incident_id or not self.header.stream_id:
            return
        entry = self.entries[row]
        dialog = EntryEditorDialog(entry.data, self, title="Edit Entry")
        if dialog.exec() == QDialog.Accepted:
            updated = dialog.result.clone()
            try:
                payload = EntryUpdate(
                    text=updated.activity,
                    timestamp_utc=_qdatetime_to_utc(updated.timestamp),
                    source=updated.source,
                    actor_user_id=updated.author or None,
                    tags=_encode_tags(updated.location, updated.links),
                    critical_flag=updated.critical,
                )
                self.services.update_entry(
                    self.incident_id,
                    entry.entry_id,
                    payload,
                )
            except Exception as exc:
                logger.exception("Failed to update entry %s: %s", entry.entry_id, exc)
                QMessageBox.critical(
                    self,
                    "Update failed",
                    f"Unable to update entry: {exc}",
                )
                return
            self._reload_current_entries()
            self._bump_version()

    def _show_table_menu(self, pos: QPoint) -> None:
        if not self.entries:
            return
        menu = QMenu(self)
        edit_action = menu.addAction("Edit")
        duplicate_action = menu.addAction("Duplicate")
        delete_action = menu.addAction("Delete")
        action = menu.exec(self.entries_table.viewport().mapToGlobal(pos))
        if action == edit_action:
            rows = {index.row() for index in self.entries_table.selectedIndexes()}
            if not rows:
                row = self.entries_table.rowAt(pos.y())
                rows = {row} if row >= 0 else set()
            for row in rows:
                self._open_editor_for_row(row, 0)
        elif action == duplicate_action:
            self._duplicate_selected()
        elif action == delete_action:
            self._delete_selected()

    def _duplicate_selected(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            return
        rows = sorted({index.row() for index in self.entries_table.selectedIndexes()})
        if not rows:
            return
        for row in rows:
            if 0 <= row < len(self.entries):
                entry = self.entries[row]
                try:
                    payload = EntryCreate(
                        text=entry.data.activity,
                        timestamp_utc=_qdatetime_to_utc(entry.data.timestamp),
                        source=entry.data.source,
                        actor_user_id=entry.data.author or None,
                        tags=_encode_tags(entry.data.location, entry.data.links),
                        critical_flag=entry.data.critical,
                    )
                    self.services.add_entry(
                        self.incident_id,
                        self.header.stream_id,
                        payload,
                    )
                except Exception as exc:
                    logger.exception("Failed to duplicate entry %s: %s", entry.entry_id, exc)
                    QMessageBox.warning(
                        self,
                        "Duplicate failed",
                        f"Unable to duplicate entry: {exc}",
                    )
        self._reload_current_entries()
        self._bump_version()

    def _delete_selected(self) -> None:
        if not self.incident_id:
            return
        rows = sorted({index.row() for index in self.entries_table.selectedIndexes()}, reverse=True)
        if not rows:
            return
        for row in rows:
            if 0 <= row < len(self.entries):
                entry_id = self.entries[row].entry_id
                try:
                    self.services.delete_entry(self.incident_id, entry_id)
                except Exception as exc:
                    logger.exception("Failed to delete entry %s: %s", entry_id, exc)
                    QMessageBox.warning(
                        self,
                        "Delete failed",
                        f"Unable to delete entry: {exc}",
                    )
        self._reload_current_entries()
        self._bump_version()

    def _on_quick_add(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            QMessageBox.warning(
                self,
                "Select Log",
                "Create or select a log before adding entries.",
            )
            return
        activity = self.quick_activity.text().strip()
        if not activity:
            QMessageBox.warning(self, "Validation", "Activity description is required.")
            return
        location = self.quick_location.text().strip()
        try:
            payload = EntryCreate(
                text=activity,
                timestamp_utc=_qdatetime_to_utc(self.quick_time.dateTime()),
                source="manual",
                tags=_encode_tags(location, []),
            )
            self.services.add_entry(
                self.incident_id,
                self.header.stream_id,
                payload,
            )
        except Exception as exc:
            logger.exception("Failed to add entry: %s", exc)
            QMessageBox.critical(
                self,
                "Add entry failed",
                f"Unable to add entry: {exc}",
            )
            return
        self.quick_activity.clear()
        self.quick_location.clear()
        self.quick_time.setDateTime(_now_local())
        self._reload_current_entries()
        self._bump_version()

    def _on_operational_period_changed(self, text: str) -> None:
        if self._loading:
            return
        data = self.op_combo.currentData()
        try:
            self.selected_op_number = int(data) if data is not None else None
        except (TypeError, ValueError):
            self.selected_op_number = _parse_op_number(data)
        if not self._applying_context:
            self._preferred_stream_id = None
        if self.launch_context:
            self._context_match_consumed = False
        self._reload_streams()

    def _open_drafts_tray(self) -> None:
        if not self.drafts:
            QMessageBox.information(self, "Drafts", "No drafts available.")
            return
        dialog = DraftsTrayDialog([draft for draft in self.drafts], self)
        dialog.entryAccepted.connect(self._accept_draft)
        dialog.entryDiscarded.connect(self._discard_draft)
        dialog.acceptAllRequested.connect(self._accept_all_drafts)
        dialog.exec()

    def _accept_draft(self, draft: DraftEntry) -> None:
        if not self.incident_id or not self.header.stream_id:
            return
        try:
            payload = EntryCreate(
                text=draft.data.activity,
                timestamp_utc=_qdatetime_to_utc(draft.data.timestamp),
                source=draft.data.source,
                actor_user_id=draft.data.author or None,
                tags=_encode_tags(draft.data.location, draft.data.links),
                critical_flag=draft.data.critical,
            )
            self.services.add_entry(
                self.incident_id,
                self.header.stream_id,
                payload,
            )
        except Exception as exc:
            logger.exception("Failed to accept draft: %s", exc)
            QMessageBox.warning(
                self,
                "Draft error",
                f"Unable to accept draft: {exc}",
            )
            return
        self._remove_draft(draft)
        self._reload_current_entries()
        self._bump_version()

    def _discard_draft(self, draft: DraftEntry) -> None:
        self._remove_draft(draft)
        self._update_review_button()

    def _accept_all_drafts(self, drafts: list[DraftEntry]) -> None:
        if not drafts:
            return
        if not self.incident_id or not self.header.stream_id:
            return
        added = False
        for draft in drafts:
            try:
                payload = EntryCreate(
                    text=draft.data.activity,
                    timestamp_utc=_qdatetime_to_utc(draft.data.timestamp),
                    source=draft.data.source,
                    actor_user_id=draft.data.author or None,
                    tags=_encode_tags(draft.data.location, draft.data.links),
                    critical_flag=draft.data.critical,
                )
                self.services.add_entry(
                    self.incident_id,
                    self.header.stream_id,
                    payload,
                )
            except Exception as exc:
                logger.exception("Failed to accept draft: %s", exc)
                QMessageBox.warning(
                    self,
                    "Draft error",
                    f"Unable to accept draft: {exc}",
                )
                continue
            self._remove_draft(draft)
            added = True
        if added:
            self._reload_current_entries()
            self._bump_version()

    def _remove_draft(self, draft: DraftEntry) -> None:
        for existing in list(self.drafts):
            if existing.draft_id == draft.draft_id:
                self.drafts.remove(existing)
                break
        self._update_review_button()

    def _close_log(self) -> None:
        QMessageBox.information(
            self,
            "Not implemented",
            "Closing logs is not yet implemented.",
        )

    def _reopen_log(self) -> None:
        QMessageBox.information(
            self,
            "Not implemented",
            "Log reopening is not yet implemented.",
        )

    def _edit_header(self) -> None:
        if not self.header.stream_id or not self.incident_id:
            QMessageBox.information(
                self,
                "No Log",
                "Select a log before editing the header.",
            )
            return
        if self.incident_id:
            self._load_subject_options()
        dialog = NewLogDialog(
            self.header.clone(),
            self.operational_period_choices,
            self,
            subject_options=self.subject_options,
            context=self.launch_context,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            data = dialog.result
            try:
                payload = StreamUpdate(
                    name=data["name"],
                    op_number=data["op_number"],
                    kind=data["kind"],
                    section=data["section"],
                )
                stream = self.services.update_stream(
                    self.incident_id,
                    self.header.stream_id,
                    payload,
                )
            except Exception as exc:
                logger.exception(
                    "Failed to update stream %s: %s",
                    self.header.stream_id,
                    exc,
                )
                QMessageBox.critical(
                    self,
                    "Update failed",
                    f"Unable to update log header: {exc}",
                )
                return
            if stream:
                new_header = self._header_from_stream(stream)
                new_header.prepared_by_name = self.header.prepared_by_name
                new_header.prepared_by_position = self.header.prepared_by_position
                new_header.notes = self.header.notes
                self._set_header(new_header)
                if self.header.stream_id:
                    self._preferred_stream_id = self.header.stream_id
                self._context_match_consumed = True
                self._reload_streams()

    def _open_new_log_dialog(self) -> None:
        if not self.incident_id:
            QMessageBox.warning(
                self,
                "Select Incident",
                "Select an incident before creating a log.",
            )
            return
        self._load_subject_options()
        dialog = NewLogDialog(
            None,
            self.operational_period_choices,
            self,
            subject_options=self.subject_options,
            context=self.launch_context,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            data = dialog.result
            try:
                payload = StreamCreate(
                    incident_id=self.incident_id,
                    name=data["name"],
                    op_number=data["op_number"],
                    kind=data["kind"],
                    section=data["section"],
                )
                stream = self.services.create_stream(payload)
            except Exception as exc:
                logger.exception("Failed to create stream: %s", exc)
                QMessageBox.critical(
                    self,
                    "Create failed",
                    f"Unable to create log: {exc}",
                )
                return
            self._preferred_stream_id = stream.id
            self._context_match_consumed = True
            self._reload_streams()

    def _on_log_changed(self, index: int) -> None:
        if index < 0:
            return
        log_id = self.log_combo.itemData(index)
        if not log_id:
            self._set_empty_state()
            return
        log_id = str(log_id)
        if self._current_log_id == log_id:
            return
        self._current_log_id = log_id
        # Once the user intentionally selects a log we stop trying to
        # auto-select based on launch context.
        self._context_match_consumed = True
        self._apply_log_state(log_id)

    def _apply_log_state(self, log_id: str) -> None:
        header = self.known_logs.get(log_id)
        if header is None and self.incident_id:
            try:
                streams = self.services.list_streams(self.incident_id)
            except Exception:
                streams = []
            for stream in streams:
                if stream.id == log_id:
                    header = self._header_from_stream(stream)
                    self.known_logs[log_id] = header
                    break
        if header is None:
            self._set_empty_state()
            return
        self._current_log_id = log_id
        self.header = header.clone()
        self._assign_operational_period(self.header)
        if self.header.op_number is not None:
            idx = self.op_combo.findData(self.header.op_number)
            if idx >= 0:
                self.op_combo.blockSignals(True)
                self.op_combo.setCurrentIndex(idx)
                self.op_combo.blockSignals(False)
                self.selected_op_number = self.header.op_number
        self._last_saved = (
            self.header.updated_at
            if self.header.updated_at and self.header.updated_at.isValid()
            else None
        )
        self.drafts = []
        self._update_header_card()
        self._reload_current_entries()
        self._update_review_button()
        self._update_footer()
        self._update_known_log()

    def _update_known_log(self) -> None:
        stream_id = self.header.stream_id
        if not stream_id:
            return
        header_clone = self.header.clone()
        self._assign_operational_period(header_clone)
        self.known_logs[stream_id] = header_clone
        idx = self.log_combo.findData(stream_id)
        if idx >= 0:
            self.log_combo.setItemText(idx, self._log_display_text(header_clone))

    def _log_display_text(self, header: LogHeader) -> str:
        parts = _unique_ordered(
            [
                header.log_for_type.title() if header.log_for_type else "",
                header.log_for_label or "",
                header.subject_label or "",
            ]
        )
        display_name = " — ".join(parts) if parts else (header.stream_id or "Log")
        period = header.operational_period or self._operational_period_label(
            header.op_number
        )
        return f"{display_name} ({period})" if period else display_name

    def _on_export(self) -> None:
        if not self.incident_id or not self.header.stream_id:
            QMessageBox.information(self, "Export", "Select a log to export.")
            return
        try:
            export = self.services.export_stream(
                self.incident_id,
                self.header.stream_id,
                ExportRequest(include_auto=True),
            )
        except Exception as exc:
            logger.exception("Failed to export log %s: %s", self.header.stream_id, exc)
            QMessageBox.critical(
                self,
                "Export failed",
                f"Unable to export log: {exc}",
            )
            return
        raw_path = getattr(export, "file_path", "")
        if raw_path:
            try:
                display_path = str(Path(raw_path).resolve())
            except Exception:  # pragma: no cover - defensive
                display_path = str(raw_path)
        else:
            display_path = "unknown location"
        QMessageBox.information(
            self,
            "Export ready",
            f"Export generated at\n{display_path}",
        )

    def _on_print(self) -> None:
        if not self.header.is_prepared():
            if not self._open_prepared_by_dialog():
                return
        QMessageBox.information(
            self,
            "Print",
            "PDF rendering pipeline placeholder — will generate ICS-214 PDF.",
        )

    def _on_filters(self) -> None:
        QMessageBox.information(
            self,
            "Filters",
            "Filter dialog placeholder — source toggles and time range forthcoming.",
        )

    def _open_prepared_by_dialog(self) -> bool:
        dialog = PreparedByDialog(
            self.header.prepared_by_name,
            self.header.prepared_by_position,
            self,
            position_hint=self.prepared_by_hint,
        )
        if dialog.exec() == QDialog.Accepted and dialog.result:
            name, position = dialog.result
            self.header.prepared_by_name = name
            self.header.prepared_by_position = position
            self._bump_version()
            return True
        return False

    def _set_header(self, header: LogHeader) -> None:
        new_header = header.clone()
        self._assign_operational_period(new_header)
        self.header = new_header
        stream_id = new_header.stream_id
        if stream_id:
            idx = self.log_combo.findData(stream_id)
            if idx >= 0:
                display = self._log_display_text(new_header)
                if self.log_combo.itemText(idx) != display:
                    self.log_combo.setItemText(idx, display)
                if self.log_combo.currentData() != stream_id:
                    self.log_combo.blockSignals(True)
                    self.log_combo.setCurrentIndex(idx)
                    self.log_combo.blockSignals(False)
        self._current_log_id = stream_id
        self._last_saved = (
            new_header.updated_at
            if new_header.updated_at and new_header.updated_at.isValid()
            else None
        )
        self._update_header_card()
        self._update_known_log()
        self._update_footer()

    def _bump_version(self, update_timestamp: bool = True) -> None:
        if self.header.stream_id:
            self.header.version += 1
        if update_timestamp:
            now = _now_local()
            self.header.updated_at = now
            self._last_saved = now
            self._update_footer()
        else:
            self._update_footer()
        self._update_header_card()
        self._update_known_log()

    def apply_launch_context(self, context: dict[str, Any]) -> None:
        self._applying_context = True
        try:
            self.launch_context = context or {}
            self.prepared_by_hint = context.get(
                "default_prepared_by_position", self.prepared_by_hint
            )
            self.default_log_type = context.get("default_log_for_type", self.default_log_type)
            self.default_log_ref = context.get("default_log_for_ref", self.default_log_ref)
            self.default_log_name = context.get("default_log_name", self.default_log_name)
            direct_stream = context.get("default_stream_id") or context.get("default_log_id")
            self._preferred_stream_id = str(direct_stream) if direct_stream else None
            # Re-run context-based selection for the next stream reload.
            self._context_match_consumed = False
            incident_overridden = False
            pin_op = context.get("pin_operational_period")
            if pin_op is not None:
                self.op_combo.setEnabled(not pin_op)
            default_incident = context.get("default_incident_id")
            if default_incident is not None:
                incident_overridden = True
                self._set_incident(str(default_incident))
            default_op = context.get("default_operational_period")
            if default_op is not None:
                try:
                    op_number = int(default_op)
                except (TypeError, ValueError):
                    op_number = _parse_op_number(default_op)
                idx = self.op_combo.findData(op_number)
                if idx >= 0:
                    self.op_combo.setCurrentIndex(idx)
            filters = context.get("default_filters")
            if filters and not self.search_edit.text():
                text_filter = filters.get("search") or ""
                if text_filter:
                    self.search_edit.setText(str(text_filter))
            if self.incident_id and not self._loading and not incident_overridden:
                self._reload_streams()
        finally:
            self._applying_context = False
